// generated by 'github.com/sacloud/libsacloud/internal/tools/gen-api-op'; DO NOT EDIT

package sacloud

import (
	"context"
	"encoding/json"

	"github.com/sacloud/libsacloud/v2/pkg/mapconv"
	"github.com/sacloud/libsacloud/v2/sacloud/types"
)

func init() {

	SetClientFactoryFunc("Archive", func(caller APICaller) interface{} {
		return &ArchiveOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "archive",
		}
	})

	SetClientFactoryFunc("Bridge", func(caller APICaller) interface{} {
		return &BridgeOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "bridge",
		}
	})

	SetClientFactoryFunc("CDROM", func(caller APICaller) interface{} {
		return &CDROMOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "cdrom",
		}
	})

	SetClientFactoryFunc("Disk", func(caller APICaller) interface{} {
		return &DiskOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "disk",
		}
	})

	SetClientFactoryFunc("GSLB", func(caller APICaller) interface{} {
		return &GSLBOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Interface", func(caller APICaller) interface{} {
		return &InterfaceOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "interface",
		}
	})

	SetClientFactoryFunc("Internet", func(caller APICaller) interface{} {
		return &InternetOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "internet",
		}
	})

	SetClientFactoryFunc("LoadBalancer", func(caller APICaller) interface{} {
		return &LoadBalancerOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("NFS", func(caller APICaller) interface{} {
		return &NFSOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("Note", func(caller APICaller) interface{} {
		return &NoteOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "note",
		}
	})

	SetClientFactoryFunc("PacketFilter", func(caller APICaller) interface{} {
		return &PacketFilterOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "packetfilter",
		}
	})

	SetClientFactoryFunc("Server", func(caller APICaller) interface{} {
		return &ServerOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "server",
		}
	})

	SetClientFactoryFunc("SIM", func(caller APICaller) interface{} {
		return &SIMOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Switch", func(caller APICaller) interface{} {
		return &SwitchOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "switch",
		}
	})

	SetClientFactoryFunc("VPCRouter", func(caller APICaller) interface{} {
		return &VPCRouterOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("Zone", func(caller APICaller) interface{} {
		return &ZoneOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "zone",
		}
	})
}

/*************************************************
* ArchiveOp
*************************************************/

// ArchiveOp implements ArchiveAPI interface
type ArchiveOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewArchiveOp creates new ArchiveOp instance
func NewArchiveOp(caller APICaller) ArchiveAPI {
	return GetClientFactoryFunc("Archive")(caller).(ArchiveAPI)
}

// Find is API call
func (o *ArchiveOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ArchiveFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &archiveFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ArchiveFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *ArchiveOp) Create(ctx context.Context, zone string, param *ArchiveCreateRequest) (*ArchiveCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &ArchiveCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *ArchiveCreateRequest `mapconv:"Archive,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &archiveCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ArchiveCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// CreateBlank is API call
func (o *ArchiveOp) CreateBlank(ctx context.Context, zone string, param *ArchiveCreateBlankRequest) (*ArchiveCreateBlankResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &ArchiveCreateBlankRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *ArchiveCreateBlankRequest `mapconv:"Archive,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &archiveCreateBlankRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveCreateBlankResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ArchiveCreateBlankResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *ArchiveOp) Read(ctx context.Context, zone string, id types.ID) (*ArchiveReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ArchiveReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *ArchiveOp) Update(ctx context.Context, zone string, id types.ID, param *ArchiveUpdateRequest) (*ArchiveUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ArchiveUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *ArchiveUpdateRequest `mapconv:"Archive,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &archiveUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ArchiveUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *ArchiveOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *ArchiveOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*ArchiveOpenFTPResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if openOption == nil {
		openOption = &OpenFTPRequest{}
	}
	args := &struct {
		Argzone       string
		Argid         types.ID
		ArgopenOption *OpenFTPRequest `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argid:         id,
		ArgopenOption: openOption,
	}

	v := &archiveOpenFTPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ArchiveOpenFTPResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// CloseFTP is API call
func (o *ArchiveOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* BridgeOp
*************************************************/

// BridgeOp implements BridgeAPI interface
type BridgeOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewBridgeOp creates new BridgeOp instance
func NewBridgeOp(caller APICaller) BridgeAPI {
	return GetClientFactoryFunc("Bridge")(caller).(BridgeAPI)
}

// Find is API call
func (o *BridgeOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*BridgeFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &bridgeFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BridgeFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *BridgeOp) Create(ctx context.Context, zone string, param *BridgeCreateRequest) (*BridgeCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &BridgeCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *BridgeCreateRequest `mapconv:"Bridge,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &bridgeCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BridgeCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *BridgeOp) Read(ctx context.Context, zone string, id types.ID) (*BridgeReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BridgeReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *BridgeOp) Update(ctx context.Context, zone string, id types.ID, param *BridgeUpdateRequest) (*BridgeUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &BridgeUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *BridgeUpdateRequest `mapconv:"Bridge,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &bridgeUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &bridgeUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &BridgeUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *BridgeOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* CDROMOp
*************************************************/

// CDROMOp implements CDROMAPI interface
type CDROMOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewCDROMOp creates new CDROMOp instance
func NewCDROMOp(caller APICaller) CDROMAPI {
	return GetClientFactoryFunc("CDROM")(caller).(CDROMAPI)
}

// Find is API call
func (o *CDROMOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*CDROMFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &cdromFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &CDROMFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *CDROMOp) Create(ctx context.Context, zone string, param *CDROMCreateRequest) (*CDROMCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &CDROMCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *CDROMCreateRequest `mapconv:"CDROM,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &cdromCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &CDROMCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *CDROMOp) Read(ctx context.Context, zone string, id types.ID) (*CDROMReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &CDROMReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *CDROMOp) Update(ctx context.Context, zone string, id types.ID, param *CDROMUpdateRequest) (*CDROMUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &CDROMUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *CDROMUpdateRequest `mapconv:"CDROM,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &cdromUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &CDROMUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *CDROMOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *CDROMOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*CDROMOpenFTPResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if openOption == nil {
		openOption = &OpenFTPRequest{}
	}
	args := &struct {
		Argzone       string
		Argid         types.ID
		ArgopenOption *OpenFTPRequest `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argid:         id,
		ArgopenOption: openOption,
	}

	v := &cdromOpenFTPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &CDROMOpenFTPResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// CloseFTP is API call
func (o *CDROMOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* DiskOp
*************************************************/

// DiskOp implements DiskAPI interface
type DiskOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDiskOp creates new DiskOp instance
func NewDiskOp(caller APICaller) DiskAPI {
	return GetClientFactoryFunc("Disk")(caller).(DiskAPI)
}

// Find is API call
func (o *DiskOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*DiskFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &diskFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *DiskOp) Create(ctx context.Context, zone string, param *DiskCreateRequest) (*DiskCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &DiskCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *DiskCreateRequest `mapconv:"Disk,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &diskCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// CreateDistantly is API call
func (o *DiskOp) CreateDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, distantFrom []types.ID) (*DiskCreateDistantlyResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"createParam": createParam,
		"distantFrom": distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		Argzone        string
		ArgcreateParam *DiskCreateRequest `mapconv:"Disk"`
		ArgdistantFrom []types.ID         `mapconv:"DistantFrom"`
	}{
		Argzone:        zone,
		ArgcreateParam: createParam,
		ArgdistantFrom: distantFrom,
	}

	v := &diskCreateDistantlyRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskCreateDistantlyResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Config is API call
func (o *DiskOp) Config(ctx context.Context, zone string, id types.ID, edit *DiskEditRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"edit":       edit,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if edit == nil {
		edit = &DiskEditRequest{}
	}
	args := &struct {
		Argzone string
		Argid   types.ID
		Argedit *DiskEditRequest `mapconv:",squash"`
	}{
		Argzone: zone,
		Argid:   id,
		Argedit: edit,
	}

	v := &diskConfigRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// CreateWithConfig is API call
func (o *DiskOp) CreateWithConfig(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool) (*DiskCreateWithConfigResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"zone":            zone,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if editParam == nil {
		editParam = &DiskEditRequest{}
	}
	if bootAtAvailable == false {
		bootAtAvailable = false
	}
	args := &struct {
		Argzone            string
		ArgcreateParam     *DiskCreateRequest `mapconv:"Disk"`
		ArgeditParam       *DiskEditRequest   `mapconv:"Config"`
		ArgbootAtAvailable bool               `mapconv:"BootAtAvailable"`
	}{
		Argzone:            zone,
		ArgcreateParam:     createParam,
		ArgeditParam:       editParam,
		ArgbootAtAvailable: bootAtAvailable,
	}

	v := &diskCreateWithConfigRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateWithConfigResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskCreateWithConfigResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// CreateWithConfigDistantly is API call
func (o *DiskOp) CreateWithConfigDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool, distantFrom []types.ID) (*DiskCreateWithConfigDistantlyResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"zone":            zone,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
		"distantFrom":     distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if createParam == nil {
		createParam = &DiskCreateRequest{}
	}
	if editParam == nil {
		editParam = &DiskEditRequest{}
	}
	if bootAtAvailable == false {
		bootAtAvailable = false
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		Argzone            string
		ArgcreateParam     *DiskCreateRequest `mapconv:"Disk"`
		ArgeditParam       *DiskEditRequest   `mapconv:"Config"`
		ArgbootAtAvailable bool               `mapconv:"BootAtAvailable"`
		ArgdistantFrom     []types.ID         `mapconv:"DistantFrom"`
	}{
		Argzone:            zone,
		ArgcreateParam:     createParam,
		ArgeditParam:       editParam,
		ArgbootAtAvailable: bootAtAvailable,
		ArgdistantFrom:     distantFrom,
	}

	v := &diskCreateWithConfigDistantlyRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateWithConfigDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskCreateWithConfigDistantlyResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// ToBlank is API call
func (o *DiskOp) ToBlank(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/blank", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ResizePartition is API call
func (o *DiskOp) ResizePartition(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/resize-partition", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToServer is API call
func (o *DiskOp) ConnectToServer(ctx context.Context, zone string, id types.ID, serverID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server/{{.serverID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"serverID":   serverID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromServer is API call
func (o *DiskOp) DisconnectFromServer(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// InstallDistantFrom is API call
func (o *DiskOp) InstallDistantFrom(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest, distantFrom []types.ID) (*DiskInstallDistantFromResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"zone":         zone,
		"id":           id,
		"installParam": installParam,
		"distantFrom":  distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if installParam == nil {
		installParam = &DiskInstallRequest{}
	}
	if distantFrom == nil {
		distantFrom = []types.ID{}
	}
	args := &struct {
		Argzone         string
		Argid           types.ID
		ArginstallParam *DiskInstallRequest `mapconv:"Disk"`
		ArgdistantFrom  []types.ID          `mapconv:"DistantFrom"`
	}{
		Argzone:         zone,
		Argid:           id,
		ArginstallParam: installParam,
		ArgdistantFrom:  distantFrom,
	}

	v := &diskInstallDistantFromRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskInstallDistantFromResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskInstallDistantFromResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Install is API call
func (o *DiskOp) Install(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest) (*DiskInstallResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"zone":         zone,
		"id":           id,
		"installParam": installParam,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if installParam == nil {
		installParam = &DiskInstallRequest{}
	}
	args := &struct {
		Argzone         string
		Argid           types.ID
		ArginstallParam *DiskInstallRequest `mapconv:"Disk"`
	}{
		Argzone:         zone,
		Argid:           id,
		ArginstallParam: installParam,
	}

	v := &diskInstallRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskInstallResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskInstallResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *DiskOp) Read(ctx context.Context, zone string, id types.ID) (*DiskReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *DiskOp) Update(ctx context.Context, zone string, id types.ID, param *DiskUpdateRequest) (*DiskUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &DiskUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *DiskUpdateRequest `mapconv:"Disk,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &diskUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *DiskOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *DiskOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*DiskMonitorResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &diskMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &DiskMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

/*************************************************
* GSLBOp
*************************************************/

// GSLBOp implements GSLBAPI interface
type GSLBOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewGSLBOp creates new GSLBOp instance
func NewGSLBOp(caller APICaller) GSLBAPI {
	return GetClientFactoryFunc("GSLB")(caller).(GSLBAPI)
}

// Find is API call
func (o *GSLBOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*GSLBFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &gslbFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gslbFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &GSLBFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *GSLBOp) Create(ctx context.Context, zone string, param *GSLBCreateRequest) (*GSLBCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &GSLBCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *GSLBCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &gslbCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gslbCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &GSLBCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *GSLBOp) Read(ctx context.Context, zone string, id types.ID) (*GSLBReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gslbReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &GSLBReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *GSLBOp) Update(ctx context.Context, zone string, id types.ID, param *GSLBUpdateRequest) (*GSLBUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &GSLBUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *GSLBUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &gslbUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gslbUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &GSLBUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *GSLBOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InterfaceOp
*************************************************/

// InterfaceOp implements InterfaceAPI interface
type InterfaceOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInterfaceOp creates new InterfaceOp instance
func NewInterfaceOp(caller APICaller) InterfaceAPI {
	return GetClientFactoryFunc("Interface")(caller).(InterfaceAPI)
}

// Find is API call
func (o *InterfaceOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*InterfaceFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &interfaceFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InterfaceFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *InterfaceOp) Create(ctx context.Context, zone string, param *InterfaceCreateRequest) (*InterfaceCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &InterfaceCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *InterfaceCreateRequest `mapconv:"Interface,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &interfaceCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InterfaceCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *InterfaceOp) Read(ctx context.Context, zone string, id types.ID) (*InterfaceReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InterfaceReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *InterfaceOp) Update(ctx context.Context, zone string, id types.ID, param *InterfaceUpdateRequest) (*InterfaceUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InterfaceUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *InterfaceUpdateRequest `mapconv:"Interface,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &interfaceUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InterfaceUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *InterfaceOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *InterfaceOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceMonitorResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &interfaceMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InterfaceMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// ConnectToSharedSegment is API call
func (o *InterfaceOp) ConnectToSharedSegment(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/shared", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *InterfaceOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *InterfaceOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToPacketFilter is API call
func (o *InterfaceOp) ConnectToPacketFilter(ctx context.Context, zone string, id types.ID, packetFilterID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter/{{.packetFilterID}}", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"packetFilterID": packetFilterID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromPacketFilter is API call
func (o *InterfaceOp) DisconnectFromPacketFilter(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InternetOp
*************************************************/

// InternetOp implements InternetAPI interface
type InternetOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInternetOp creates new InternetOp instance
func NewInternetOp(caller APICaller) InternetAPI {
	return GetClientFactoryFunc("Internet")(caller).(InternetAPI)
}

// Find is API call
func (o *InternetOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*InternetFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &internetFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *InternetOp) Create(ctx context.Context, zone string, param *InternetCreateRequest) (*InternetCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &InternetCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *InternetCreateRequest `mapconv:"Internet,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &internetCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *InternetOp) Read(ctx context.Context, zone string, id types.ID) (*InternetReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *InternetOp) Update(ctx context.Context, zone string, id types.ID, param *InternetUpdateRequest) (*InternetUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *InternetUpdateRequest `mapconv:"Internet,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &internetUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *InternetOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// UpdateBandWidth is API call
func (o *InternetOp) UpdateBandWidth(ctx context.Context, zone string, id types.ID, param *InternetUpdateBandWidthRequest) (*InternetUpdateBandWidthResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/bandwidth", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateBandWidthRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *InternetUpdateBandWidthRequest `mapconv:"Internet,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &internetUpdateBandWidthRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateBandWidthResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetUpdateBandWidthResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// AddSubnet is API call
func (o *InternetOp) AddSubnet(ctx context.Context, zone string, id types.ID, param *InternetAddSubnetRequest) (*InternetAddSubnetResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetAddSubnetRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *InternetAddSubnetRequest `mapconv:",squash"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &internetAddSubnetRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetAddSubnetResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetAddSubnetResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// UpdateSubnet is API call
func (o *InternetOp) UpdateSubnet(ctx context.Context, zone string, id types.ID, subnetID types.ID, param *InternetUpdateSubnetRequest) (*InternetUpdateSubnetResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet/{{.subnetID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"subnetID":   subnetID,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if subnetID == types.ID(int64(0)) {
		subnetID = types.ID(int64(0))
	}
	if param == nil {
		param = &InternetUpdateSubnetRequest{}
	}
	args := &struct {
		Argzone     string
		Argid       types.ID
		ArgsubnetID types.ID
		Argparam    *InternetUpdateSubnetRequest `mapconv:",squash"`
	}{
		Argzone:     zone,
		Argid:       id,
		ArgsubnetID: subnetID,
		Argparam:    param,
	}

	v := &internetUpdateSubnetRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetUpdateSubnetResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetUpdateSubnetResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// DeleteSubnet is API call
func (o *InternetOp) DeleteSubnet(ctx context.Context, zone string, id types.ID, subnetID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/subnet/{{.subnetID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"subnetID":   subnetID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *InternetOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InternetMonitorResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &internetMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &internetMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &InternetMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

/*************************************************
* LoadBalancerOp
*************************************************/

// LoadBalancerOp implements LoadBalancerAPI interface
type LoadBalancerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewLoadBalancerOp creates new LoadBalancerOp instance
func NewLoadBalancerOp(caller APICaller) LoadBalancerAPI {
	return GetClientFactoryFunc("LoadBalancer")(caller).(LoadBalancerAPI)
}

// Find is API call
func (o *LoadBalancerOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*LoadBalancerFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &loadbalancerFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *LoadBalancerOp) Create(ctx context.Context, zone string, param *LoadBalancerCreateRequest) (*LoadBalancerCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &LoadBalancerCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *LoadBalancerCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &loadbalancerCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *LoadBalancerOp) Read(ctx context.Context, zone string, id types.ID) (*LoadBalancerReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *LoadBalancerOp) Update(ctx context.Context, zone string, id types.ID, param *LoadBalancerUpdateRequest) (*LoadBalancerUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &LoadBalancerUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *LoadBalancerUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &loadbalancerUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *LoadBalancerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *LoadBalancerOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *LoadBalancerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *LoadBalancerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argzone           string
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argzone:           zone,
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &loadbalancerShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *LoadBalancerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorInterface is API call
func (o *LoadBalancerOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*LoadBalancerMonitorInterfaceResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &loadbalancerMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Status is API call
func (o *LoadBalancerOp) Status(ctx context.Context, zone string, id types.ID) (*LoadBalancerStatusResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/status", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &LoadBalancerStatusResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

/*************************************************
* NFSOp
*************************************************/

// NFSOp implements NFSAPI interface
type NFSOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNFSOp creates new NFSOp instance
func NewNFSOp(caller APICaller) NFSAPI {
	return GetClientFactoryFunc("NFS")(caller).(NFSAPI)
}

// Find is API call
func (o *NFSOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*NFSFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &nfsFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NFSFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *NFSOp) Create(ctx context.Context, zone string, param *NFSCreateRequest) (*NFSCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &NFSCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *NFSCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &nfsCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NFSCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *NFSOp) Read(ctx context.Context, zone string, id types.ID) (*NFSReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NFSReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *NFSOp) Update(ctx context.Context, zone string, id types.ID, param *NFSUpdateRequest) (*NFSUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &NFSUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *NFSUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &nfsUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NFSUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *NFSOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *NFSOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *NFSOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argzone           string
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argzone:           zone,
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &nfsShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *NFSOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorFreeDiskSize is API call
func (o *NFSOp) MonitorFreeDiskSize(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*NFSMonitorFreeDiskSizeResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/database/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &nfsMonitorFreeDiskSizeRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsMonitorFreeDiskSizeResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NFSMonitorFreeDiskSizeResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// MonitorInterface is API call
func (o *NFSOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*NFSMonitorInterfaceResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &nfsMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NFSMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

/*************************************************
* NoteOp
*************************************************/

// NoteOp implements NoteAPI interface
type NoteOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNoteOp creates new NoteOp instance
func NewNoteOp(caller APICaller) NoteAPI {
	return GetClientFactoryFunc("Note")(caller).(NoteAPI)
}

// Find is API call
func (o *NoteOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*NoteFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &noteFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NoteFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *NoteOp) Create(ctx context.Context, zone string, param *NoteCreateRequest) (*NoteCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &NoteCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *NoteCreateRequest `mapconv:"Note,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &noteCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NoteCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *NoteOp) Read(ctx context.Context, zone string, id types.ID) (*NoteReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NoteReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *NoteOp) Update(ctx context.Context, zone string, id types.ID, param *NoteUpdateRequest) (*NoteUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &NoteUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *NoteUpdateRequest `mapconv:"Note,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &noteUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &NoteUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *NoteOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* PacketFilterOp
*************************************************/

// PacketFilterOp implements PacketFilterAPI interface
type PacketFilterOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewPacketFilterOp creates new PacketFilterOp instance
func NewPacketFilterOp(caller APICaller) PacketFilterAPI {
	return GetClientFactoryFunc("PacketFilter")(caller).(PacketFilterAPI)
}

// Find is API call
func (o *PacketFilterOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*PacketFilterFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &packetfilterFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetfilterFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &PacketFilterFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *PacketFilterOp) Create(ctx context.Context, zone string, param *PacketFilterCreateRequest) (*PacketFilterCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &PacketFilterCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *PacketFilterCreateRequest `mapconv:"PacketFilter,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &packetfilterCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetfilterCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &PacketFilterCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *PacketFilterOp) Read(ctx context.Context, zone string, id types.ID) (*PacketFilterReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetfilterReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &PacketFilterReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *PacketFilterOp) Update(ctx context.Context, zone string, id types.ID, param *PacketFilterUpdateRequest) (*PacketFilterUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &PacketFilterUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *PacketFilterUpdateRequest `mapconv:"PacketFilter,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &packetfilterUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &packetfilterUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &PacketFilterUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *PacketFilterOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* ServerOp
*************************************************/

// ServerOp implements ServerAPI interface
type ServerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewServerOp creates new ServerOp instance
func NewServerOp(caller APICaller) ServerAPI {
	return GetClientFactoryFunc("Server")(caller).(ServerAPI)
}

// Find is API call
func (o *ServerOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ServerFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &serverFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *ServerOp) Create(ctx context.Context, zone string, param *ServerCreateRequest) (*ServerCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &ServerCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *ServerCreateRequest `mapconv:"Server,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &serverCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *ServerOp) Read(ctx context.Context, zone string, id types.ID) (*ServerReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *ServerOp) Update(ctx context.Context, zone string, id types.ID, param *ServerUpdateRequest) (*ServerUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &ServerUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *ServerUpdateRequest `mapconv:"Server,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &serverUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *ServerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ChangePlan is API call
func (o *ServerOp) ChangePlan(ctx context.Context, zone string, id types.ID, plan *ServerChangePlanRequest) (*ServerChangePlanResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/plan", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"plan":       plan,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if plan == nil {
		plan = &ServerChangePlanRequest{}
	}
	args := &struct {
		Argzone string
		Argid   types.ID
		Argplan *ServerChangePlanRequest `mapconv:",squash"`
	}{
		Argzone: zone,
		Argid:   id,
		Argplan: plan,
	}

	v := &serverChangePlanRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverChangePlanResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerChangePlanResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// InsertCDROM is API call
func (o *ServerOp) InsertCDROM(ctx context.Context, zone string, id types.ID, insertParam *InsertCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if insertParam == nil {
		insertParam = &InsertCDROMRequest{}
	}
	args := &struct {
		Argzone        string
		Argid          types.ID
		ArginsertParam *InsertCDROMRequest `mapconv:"CDROM"`
	}{
		Argzone:        zone,
		Argid:          id,
		ArginsertParam: insertParam,
	}

	v := &serverInsertCDROMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// EjectCDROM is API call
func (o *ServerOp) EjectCDROM(ctx context.Context, zone string, id types.ID, insertParam *EjectCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if insertParam == nil {
		insertParam = &EjectCDROMRequest{}
	}
	args := &struct {
		Argzone        string
		Argid          types.ID
		ArginsertParam *EjectCDROMRequest `mapconv:"CDROM"`
	}{
		Argzone:        zone,
		Argid:          id,
		ArginsertParam: insertParam,
	}

	v := &serverEjectCDROMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *ServerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *ServerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argzone           string
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argzone:           zone,
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &serverShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *ServerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *ServerOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*ServerMonitorResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &serverMonitorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ServerMonitorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

/*************************************************
* SIMOp
*************************************************/

// SIMOp implements SIMAPI interface
type SIMOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSIMOp creates new SIMOp instance
func NewSIMOp(caller APICaller) SIMAPI {
	return GetClientFactoryFunc("SIM")(caller).(SIMAPI)
}

// Find is API call
func (o *SIMOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*SIMFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &simFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *SIMOp) Create(ctx context.Context, zone string, param *SIMCreateRequest) (*SIMCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &SIMCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *SIMCreateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &simCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *SIMOp) Read(ctx context.Context, zone string, id types.ID) (*SIMReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *SIMOp) Update(ctx context.Context, zone string, id types.ID, param *SIMUpdateRequest) (*SIMUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SIMUpdateRequest `mapconv:"CommonServiceItem,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &simUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *SIMOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Activate is API call
func (o *SIMOp) Activate(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/activate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Deactivate is API call
func (o *SIMOp) Deactivate(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/deactivate", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// AssignIP is API call
func (o *SIMOp) AssignIP(ctx context.Context, zone string, id types.ID, param *SIMAssignIPRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/ip", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMAssignIPRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SIMAssignIPRequest `mapconv:"SIM,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &simAssignIPRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ClearIP is API call
func (o *SIMOp) ClearIP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/ip", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// IMEILock is API call
func (o *SIMOp) IMEILock(ctx context.Context, zone string, id types.ID, param *SIMIMEILockRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/imeilock", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SIMIMEILockRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SIMIMEILockRequest `mapconv:"SIM,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &simIMEILockRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// IMEIUnlock is API call
func (o *SIMOp) IMEIUnlock(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/imeilock", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Logs is API call
func (o *SIMOp) Logs(ctx context.Context, zone string, id types.ID) (*SIMLogsResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/sessionlog", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simLogsResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMLogsResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// GetNetworkOperator is API call
func (o *SIMOp) GetNetworkOperator(ctx context.Context, zone string, id types.ID) (*SIMGetNetworkOperatorResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/network_operator_config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simGetNetworkOperatorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMGetNetworkOperatorResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// SetNetworkOperator is API call
func (o *SIMOp) SetNetworkOperator(ctx context.Context, zone string, id types.ID, configs *SIMNetworkOperatorConfigs) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/network_operator_config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"configs":    configs,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if configs == nil {
		configs = &SIMNetworkOperatorConfigs{}
	}
	args := &struct {
		Argzone    string
		Argid      types.ID
		Argconfigs *SIMNetworkOperatorConfigs `mapconv:",squash"`
	}{
		Argzone:    zone,
		Argid:      id,
		Argconfigs: configs,
	}

	v := &simSetNetworkOperatorRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorSIM is API call
func (o *SIMOp) MonitorSIM(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*SIMMonitorSIMResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/sim/metrics/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argcondition: condition,
	}

	v := &simMonitorSIMRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &simMonitorSIMResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SIMMonitorSIMResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

/*************************************************
* SwitchOp
*************************************************/

// SwitchOp implements SwitchAPI interface
type SwitchOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSwitchOp creates new SwitchOp instance
func NewSwitchOp(caller APICaller) SwitchAPI {
	return GetClientFactoryFunc("Switch")(caller).(SwitchAPI)
}

// Find is API call
func (o *SwitchOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*SwitchFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &switchFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SwitchFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *SwitchOp) Create(ctx context.Context, zone string, param *SwitchCreateRequest) (*SwitchCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &SwitchCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *SwitchCreateRequest `mapconv:"Switch,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &switchCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SwitchCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *SwitchOp) Read(ctx context.Context, zone string, id types.ID) (*SwitchReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SwitchReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *SwitchOp) Update(ctx context.Context, zone string, id types.ID, param *SwitchUpdateRequest) (*SwitchUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &SwitchUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *SwitchUpdateRequest `mapconv:"Switch,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &switchUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &SwitchUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *SwitchOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToBridge is API call
func (o *SwitchOp) ConnectToBridge(ctx context.Context, zone string, id types.ID, bridgeID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge/{{.bridgeID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"bridgeID":   bridgeID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromBridge is API call
func (o *SwitchOp) DisconnectFromBridge(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge/", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* VPCRouterOp
*************************************************/

// VPCRouterOp implements VPCRouterAPI interface
type VPCRouterOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewVPCRouterOp creates new VPCRouterOp instance
func NewVPCRouterOp(caller APICaller) VPCRouterAPI {
	return GetClientFactoryFunc("VPCRouter")(caller).(VPCRouterAPI)
}

// Find is API call
func (o *VPCRouterOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*VPCRouterFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &vpcrouterFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vpcrouterFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &VPCRouterFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Create is API call
func (o *VPCRouterOp) Create(ctx context.Context, zone string, param *VPCRouterCreateRequest) (*VPCRouterCreateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if param == nil {
		param = &VPCRouterCreateRequest{}
	}
	args := &struct {
		Argzone  string
		Argparam *VPCRouterCreateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argparam: param,
	}

	v := &vpcrouterCreateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vpcrouterCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &VPCRouterCreateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *VPCRouterOp) Read(ctx context.Context, zone string, id types.ID) (*VPCRouterReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vpcrouterReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &VPCRouterReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Update is API call
func (o *VPCRouterOp) Update(ctx context.Context, zone string, id types.ID, param *VPCRouterUpdateRequest) (*VPCRouterUpdateResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if param == nil {
		param = &VPCRouterUpdateRequest{}
	}
	args := &struct {
		Argzone  string
		Argid    types.ID
		Argparam *VPCRouterUpdateRequest `mapconv:"Appliance,recursive"`
	}{
		Argzone:  zone,
		Argid:    id,
		Argparam: param,
	}

	v := &vpcrouterUpdateRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vpcrouterUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &VPCRouterUpdateResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Delete is API call
func (o *VPCRouterOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *VPCRouterOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *VPCRouterOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *VPCRouterOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if shutdownOption == nil {
		shutdownOption = &ShutdownOption{}
	}
	args := &struct {
		Argzone           string
		Argid             types.ID
		ArgshutdownOption *ShutdownOption `mapconv:",squash"`
	}{
		Argzone:           zone,
		Argid:             id,
		ArgshutdownOption: shutdownOption,
	}

	v := &vpcrouterShutdownRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return err
	}
	body = v

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *VPCRouterOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *VPCRouterOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, nicIndex int, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{.nicIndex}}/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"nicIndex":   nicIndex,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *VPCRouterOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID, nicIndex int) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{.nicIndex}}/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"nicIndex":   nicIndex,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorInterface is API call
func (o *VPCRouterOp) MonitorInterface(ctx context.Context, zone string, id types.ID, index int, condition *MonitorCondition) (*VPCRouterMonitorInterfaceResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/{{if eq .index 0}}{{.index}}{{end}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"index":      index,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if id == types.ID(int64(0)) {
		id = types.ID(int64(0))
	}
	if index == 0 {
		index = 0
	}
	if condition == nil {
		condition = &MonitorCondition{}
	}
	args := &struct {
		Argzone      string
		Argid        types.ID
		Argindex     int
		Argcondition *MonitorCondition `mapconv:",squash"`
	}{
		Argzone:      zone,
		Argid:        id,
		Argindex:     index,
		Argcondition: condition,
	}

	v := &vpcrouterMonitorInterfaceRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &vpcrouterMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &VPCRouterMonitorInterfaceResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

/*************************************************
* ZoneOp
*************************************************/

// ZoneOp implements ZoneAPI interface
type ZoneOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewZoneOp creates new ZoneOp instance
func NewZoneOp(caller APICaller) ZoneAPI {
	return GetClientFactoryFunc("Zone")(caller).(ZoneAPI)
}

// Find is API call
func (o *ZoneOp) Find(ctx context.Context, zone string, conditions *FindCondition) (*ZoneFindResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	if zone == "" {
		zone = ""
	}
	if conditions == nil {
		conditions = &FindCondition{}
	}
	args := &struct {
		Argzone       string
		Argconditions *FindCondition `mapconv:",squash"`
	}{
		Argzone:       zone,
		Argconditions: conditions,
	}

	v := &zoneFindRequestEnvelope{}
	if err := mapconv.ConvertTo(args, v); err != nil {
		return nil, err
	}
	body = v

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &zoneFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ZoneFindResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}

// Read is API call
func (o *ZoneOp) Read(ctx context.Context, zone string, id types.ID) (*ZoneReadResult, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &zoneReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	results := &ZoneReadResult{}
	if err := mapconv.ConvertFrom(nakedResponse, results); err != nil {
		return nil, err
	}
	return results, nil
}
