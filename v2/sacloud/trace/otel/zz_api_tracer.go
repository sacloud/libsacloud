// Copyright 2016-2021 The Libsacloud Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// generated by 'github.com/sacloud/libsacloud/internal/tools/gen-otel-tracer'; DO NOT EDIT

package otel

import (
	"context"

	"github.com/sacloud/libsacloud/v2/sacloud"
	"github.com/sacloud/libsacloud/v2/sacloud/types"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/label"
	"go.opentelemetry.io/otel/trace"
)

func addClientFactoryHooks(cnf *config) {
	sacloud.AddClientFacotyHookFunc("Archive", func(in interface{}) interface{} {
		return newArchiveTracer(in.(sacloud.ArchiveAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("AuthStatus", func(in interface{}) interface{} {
		return newAuthStatusTracer(in.(sacloud.AuthStatusAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("AutoBackup", func(in interface{}) interface{} {
		return newAutoBackupTracer(in.(sacloud.AutoBackupAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Bill", func(in interface{}) interface{} {
		return newBillTracer(in.(sacloud.BillAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Bridge", func(in interface{}) interface{} {
		return newBridgeTracer(in.(sacloud.BridgeAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("CDROM", func(in interface{}) interface{} {
		return newCDROMTracer(in.(sacloud.CDROMAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("ContainerRegistry", func(in interface{}) interface{} {
		return newContainerRegistryTracer(in.(sacloud.ContainerRegistryAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Coupon", func(in interface{}) interface{} {
		return newCouponTracer(in.(sacloud.CouponAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Database", func(in interface{}) interface{} {
		return newDatabaseTracer(in.(sacloud.DatabaseAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Disk", func(in interface{}) interface{} {
		return newDiskTracer(in.(sacloud.DiskAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("DiskPlan", func(in interface{}) interface{} {
		return newDiskPlanTracer(in.(sacloud.DiskPlanAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("DNS", func(in interface{}) interface{} {
		return newDNSTracer(in.(sacloud.DNSAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("ESME", func(in interface{}) interface{} {
		return newESMETracer(in.(sacloud.ESMEAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("GSLB", func(in interface{}) interface{} {
		return newGSLBTracer(in.(sacloud.GSLBAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Icon", func(in interface{}) interface{} {
		return newIconTracer(in.(sacloud.IconAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Interface", func(in interface{}) interface{} {
		return newInterfaceTracer(in.(sacloud.InterfaceAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Internet", func(in interface{}) interface{} {
		return newInternetTracer(in.(sacloud.InternetAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("InternetPlan", func(in interface{}) interface{} {
		return newInternetPlanTracer(in.(sacloud.InternetPlanAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("IPAddress", func(in interface{}) interface{} {
		return newIPAddressTracer(in.(sacloud.IPAddressAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("IPv6Net", func(in interface{}) interface{} {
		return newIPv6NetTracer(in.(sacloud.IPv6NetAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("IPv6Addr", func(in interface{}) interface{} {
		return newIPv6AddrTracer(in.(sacloud.IPv6AddrAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("License", func(in interface{}) interface{} {
		return newLicenseTracer(in.(sacloud.LicenseAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("LicenseInfo", func(in interface{}) interface{} {
		return newLicenseInfoTracer(in.(sacloud.LicenseInfoAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("LoadBalancer", func(in interface{}) interface{} {
		return newLoadBalancerTracer(in.(sacloud.LoadBalancerAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("LocalRouter", func(in interface{}) interface{} {
		return newLocalRouterTracer(in.(sacloud.LocalRouterAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("MobileGateway", func(in interface{}) interface{} {
		return newMobileGatewayTracer(in.(sacloud.MobileGatewayAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("NFS", func(in interface{}) interface{} {
		return newNFSTracer(in.(sacloud.NFSAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Note", func(in interface{}) interface{} {
		return newNoteTracer(in.(sacloud.NoteAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("PacketFilter", func(in interface{}) interface{} {
		return newPacketFilterTracer(in.(sacloud.PacketFilterAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("PrivateHost", func(in interface{}) interface{} {
		return newPrivateHostTracer(in.(sacloud.PrivateHostAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("PrivateHostPlan", func(in interface{}) interface{} {
		return newPrivateHostPlanTracer(in.(sacloud.PrivateHostPlanAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("ProxyLB", func(in interface{}) interface{} {
		return newProxyLBTracer(in.(sacloud.ProxyLBAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Region", func(in interface{}) interface{} {
		return newRegionTracer(in.(sacloud.RegionAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Server", func(in interface{}) interface{} {
		return newServerTracer(in.(sacloud.ServerAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("ServerPlan", func(in interface{}) interface{} {
		return newServerPlanTracer(in.(sacloud.ServerPlanAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("ServiceClass", func(in interface{}) interface{} {
		return newServiceClassTracer(in.(sacloud.ServiceClassAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("SIM", func(in interface{}) interface{} {
		return newSIMTracer(in.(sacloud.SIMAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("SimpleMonitor", func(in interface{}) interface{} {
		return newSimpleMonitorTracer(in.(sacloud.SimpleMonitorAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("SSHKey", func(in interface{}) interface{} {
		return newSSHKeyTracer(in.(sacloud.SSHKeyAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Subnet", func(in interface{}) interface{} {
		return newSubnetTracer(in.(sacloud.SubnetAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Switch", func(in interface{}) interface{} {
		return newSwitchTracer(in.(sacloud.SwitchAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("VPCRouter", func(in interface{}) interface{} {
		return newVPCRouterTracer(in.(sacloud.VPCRouterAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("WebAccel", func(in interface{}) interface{} {
		return newWebAccelTracer(in.(sacloud.WebAccelAPI), cnf)
	})
	sacloud.AddClientFacotyHookFunc("Zone", func(in interface{}) interface{} {
		return newZoneTracer(in.(sacloud.ZoneAPI), cnf)
	})
}

/*************************************************
* ArchiveTracer
*************************************************/

// ArchiveTracer is for trace ArchiveOp operations
type ArchiveTracer struct {
	Internal sacloud.ArchiveAPI
	config   *config
}

// NewArchiveTracer creates new ArchiveTracer instance
func newArchiveTracer(in sacloud.ArchiveAPI, cnf *config) sacloud.ArchiveAPI {
	return &ArchiveTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *ArchiveTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.ArchiveFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *ArchiveTracer) Create(ctx context.Context, zone string, param *sacloud.ArchiveCreateRequest) (*sacloud.Archive, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultArchive, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultArchive", resultArchive))

	}
	return resultArchive, err
}

// CreateBlank is API call with trace log
func (t *ArchiveTracer) CreateBlank(ctx context.Context, zone string, param *sacloud.ArchiveCreateBlankRequest) (*sacloud.Archive, *sacloud.FTPServer, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.CreateBlank", options...)
	defer func() {
		span.End()
	}()

	resultArchive, resultFTPServer, err := t.Internal.CreateBlank(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultArchive", resultArchive))
		span.SetAttributes(label.Any("libsacloud.api.results.resultFTPServer", resultFTPServer))

	}
	return resultArchive, resultFTPServer, err
}

// Read is API call with trace log
func (t *ArchiveTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Archive, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultArchive, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultArchive", resultArchive))

	}
	return resultArchive, err
}

// Update is API call with trace log
func (t *ArchiveTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.ArchiveUpdateRequest) (*sacloud.Archive, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultArchive, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultArchive", resultArchive))

	}
	return resultArchive, err
}

// Delete is API call with trace log
func (t *ArchiveTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// OpenFTP is API call with trace log
func (t *ArchiveTracer) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *sacloud.OpenFTPRequest) (*sacloud.FTPServer, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.openOption", openOption),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.OpenFTP", options...)
	defer func() {
		span.End()
	}()

	resultFTPServer, err := t.Internal.OpenFTP(ctx, zone, id, openOption)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultFTPServer", resultFTPServer))

	}
	return resultFTPServer, err
}

// CloseFTP is API call with trace log
func (t *ArchiveTracer) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.CloseFTP", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.CloseFTP(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Share is API call with trace log
func (t *ArchiveTracer) Share(ctx context.Context, zone string, id types.ID) (*sacloud.ArchiveShareInfo, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.Share", options...)
	defer func() {
		span.End()
	}()

	resultArchiveShareInfo, err := t.Internal.Share(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultArchiveShareInfo", resultArchiveShareInfo))

	}
	return resultArchiveShareInfo, err
}

// CreateFromShared is API call with trace log
func (t *ArchiveTracer) CreateFromShared(ctx context.Context, zone string, sourceArchiveID types.ID, destZoneID types.ID, param *sacloud.ArchiveCreateRequestFromShared) (*sacloud.Archive, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.sourceArchiveID", sourceArchiveID),
		label.Any("libsacloud.api.arguments.destZoneID", destZoneID),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.CreateFromShared", options...)
	defer func() {
		span.End()
	}()

	resultArchive, err := t.Internal.CreateFromShared(ctx, zone, sourceArchiveID, destZoneID, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultArchive", resultArchive))

	}
	return resultArchive, err
}

// Transfer is API call with trace log
func (t *ArchiveTracer) Transfer(ctx context.Context, zone string, sourceArchiveID types.ID, destZoneID types.ID, param *sacloud.ArchiveTransferRequest) (*sacloud.Archive, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.sourceArchiveID", sourceArchiveID),
		label.Any("libsacloud.api.arguments.destZoneID", destZoneID),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ArchiveAPI.Transfer", options...)
	defer func() {
		span.End()
	}()

	resultArchive, err := t.Internal.Transfer(ctx, zone, sourceArchiveID, destZoneID, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultArchive", resultArchive))

	}
	return resultArchive, err
}

/*************************************************
* AuthStatusTracer
*************************************************/

// AuthStatusTracer is for trace AuthStatusOp operations
type AuthStatusTracer struct {
	Internal sacloud.AuthStatusAPI
	config   *config
}

// NewAuthStatusTracer creates new AuthStatusTracer instance
func newAuthStatusTracer(in sacloud.AuthStatusAPI, cnf *config) sacloud.AuthStatusAPI {
	return &AuthStatusTracer{
		Internal: in,
		config:   cnf,
	}
}

// Read is API call with trace log
func (t *AuthStatusTracer) Read(ctx context.Context) (*sacloud.AuthStatus, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes())
	ctx, span = t.config.Tracer.Start(ctx, "AuthStatusAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultAuthStatus, err := t.Internal.Read(ctx)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultAuthStatus", resultAuthStatus))

	}
	return resultAuthStatus, err
}

/*************************************************
* AutoBackupTracer
*************************************************/

// AutoBackupTracer is for trace AutoBackupOp operations
type AutoBackupTracer struct {
	Internal sacloud.AutoBackupAPI
	config   *config
}

// NewAutoBackupTracer creates new AutoBackupTracer instance
func newAutoBackupTracer(in sacloud.AutoBackupAPI, cnf *config) sacloud.AutoBackupAPI {
	return &AutoBackupTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *AutoBackupTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.AutoBackupFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "AutoBackupAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *AutoBackupTracer) Create(ctx context.Context, zone string, param *sacloud.AutoBackupCreateRequest) (*sacloud.AutoBackup, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "AutoBackupAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultAutoBackup, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultAutoBackup", resultAutoBackup))

	}
	return resultAutoBackup, err
}

// Read is API call with trace log
func (t *AutoBackupTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.AutoBackup, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "AutoBackupAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultAutoBackup, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultAutoBackup", resultAutoBackup))

	}
	return resultAutoBackup, err
}

// Update is API call with trace log
func (t *AutoBackupTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.AutoBackupUpdateRequest) (*sacloud.AutoBackup, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "AutoBackupAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultAutoBackup, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultAutoBackup", resultAutoBackup))

	}
	return resultAutoBackup, err
}

// UpdateSettings is API call with trace log
func (t *AutoBackupTracer) UpdateSettings(ctx context.Context, zone string, id types.ID, param *sacloud.AutoBackupUpdateSettingsRequest) (*sacloud.AutoBackup, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "AutoBackupAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultAutoBackup, err := t.Internal.UpdateSettings(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultAutoBackup", resultAutoBackup))

	}
	return resultAutoBackup, err
}

// Delete is API call with trace log
func (t *AutoBackupTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "AutoBackupAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* BillTracer
*************************************************/

// BillTracer is for trace BillOp operations
type BillTracer struct {
	Internal sacloud.BillAPI
	config   *config
}

// NewBillTracer creates new BillTracer instance
func newBillTracer(in sacloud.BillAPI, cnf *config) sacloud.BillAPI {
	return &BillTracer{
		Internal: in,
		config:   cnf,
	}
}

// ByContract is API call with trace log
func (t *BillTracer) ByContract(ctx context.Context, accountID types.ID) (*sacloud.BillByContractResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.accountID", accountID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BillAPI.ByContract", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.ByContract(ctx, accountID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// ByContractYear is API call with trace log
func (t *BillTracer) ByContractYear(ctx context.Context, accountID types.ID, year int) (*sacloud.BillByContractYearResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.accountID", accountID),
		label.Any("libsacloud.api.arguments.year", year),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BillAPI.ByContractYear", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.ByContractYear(ctx, accountID, year)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// ByContractYearMonth is API call with trace log
func (t *BillTracer) ByContractYearMonth(ctx context.Context, accountID types.ID, year int, month int) (*sacloud.BillByContractYearMonthResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.accountID", accountID),
		label.Any("libsacloud.api.arguments.year", year),
		label.Any("libsacloud.api.arguments.month", month),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BillAPI.ByContractYearMonth", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.ByContractYearMonth(ctx, accountID, year, month)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *BillTracer) Read(ctx context.Context, id types.ID) (*sacloud.BillReadResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BillAPI.Read", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Details is API call with trace log
func (t *BillTracer) Details(ctx context.Context, MemberCode string, id types.ID) (*sacloud.BillDetailsResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.MemberCode", MemberCode),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BillAPI.Details", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Details(ctx, MemberCode, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// DetailsCSV is API call with trace log
func (t *BillTracer) DetailsCSV(ctx context.Context, MemberCode string, id types.ID) (*sacloud.BillDetailCSV, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.MemberCode", MemberCode),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BillAPI.DetailsCSV", options...)
	defer func() {
		span.End()
	}()

	resultBillDetailCSV, err := t.Internal.DetailsCSV(ctx, MemberCode, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultBillDetailCSV", resultBillDetailCSV))

	}
	return resultBillDetailCSV, err
}

/*************************************************
* BridgeTracer
*************************************************/

// BridgeTracer is for trace BridgeOp operations
type BridgeTracer struct {
	Internal sacloud.BridgeAPI
	config   *config
}

// NewBridgeTracer creates new BridgeTracer instance
func newBridgeTracer(in sacloud.BridgeAPI, cnf *config) sacloud.BridgeAPI {
	return &BridgeTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *BridgeTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.BridgeFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BridgeAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *BridgeTracer) Create(ctx context.Context, zone string, param *sacloud.BridgeCreateRequest) (*sacloud.Bridge, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BridgeAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultBridge, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultBridge", resultBridge))

	}
	return resultBridge, err
}

// Read is API call with trace log
func (t *BridgeTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Bridge, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BridgeAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultBridge, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultBridge", resultBridge))

	}
	return resultBridge, err
}

// Update is API call with trace log
func (t *BridgeTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.BridgeUpdateRequest) (*sacloud.Bridge, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BridgeAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultBridge, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultBridge", resultBridge))

	}
	return resultBridge, err
}

// Delete is API call with trace log
func (t *BridgeTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "BridgeAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* CDROMTracer
*************************************************/

// CDROMTracer is for trace CDROMOp operations
type CDROMTracer struct {
	Internal sacloud.CDROMAPI
	config   *config
}

// NewCDROMTracer creates new CDROMTracer instance
func newCDROMTracer(in sacloud.CDROMAPI, cnf *config) sacloud.CDROMAPI {
	return &CDROMTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *CDROMTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.CDROMFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "CDROMAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *CDROMTracer) Create(ctx context.Context, zone string, param *sacloud.CDROMCreateRequest) (*sacloud.CDROM, *sacloud.FTPServer, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "CDROMAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultCDROM, resultFTPServer, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCDROM", resultCDROM))
		span.SetAttributes(label.Any("libsacloud.api.results.resultFTPServer", resultFTPServer))

	}
	return resultCDROM, resultFTPServer, err
}

// Read is API call with trace log
func (t *CDROMTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.CDROM, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "CDROMAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultCDROM, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCDROM", resultCDROM))

	}
	return resultCDROM, err
}

// Update is API call with trace log
func (t *CDROMTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.CDROMUpdateRequest) (*sacloud.CDROM, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "CDROMAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultCDROM, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCDROM", resultCDROM))

	}
	return resultCDROM, err
}

// Delete is API call with trace log
func (t *CDROMTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "CDROMAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// OpenFTP is API call with trace log
func (t *CDROMTracer) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *sacloud.OpenFTPRequest) (*sacloud.FTPServer, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.openOption", openOption),
	))
	ctx, span = t.config.Tracer.Start(ctx, "CDROMAPI.OpenFTP", options...)
	defer func() {
		span.End()
	}()

	resultFTPServer, err := t.Internal.OpenFTP(ctx, zone, id, openOption)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultFTPServer", resultFTPServer))

	}
	return resultFTPServer, err
}

// CloseFTP is API call with trace log
func (t *CDROMTracer) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "CDROMAPI.CloseFTP", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.CloseFTP(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* ContainerRegistryTracer
*************************************************/

// ContainerRegistryTracer is for trace ContainerRegistryOp operations
type ContainerRegistryTracer struct {
	Internal sacloud.ContainerRegistryAPI
	config   *config
}

// NewContainerRegistryTracer creates new ContainerRegistryTracer instance
func newContainerRegistryTracer(in sacloud.ContainerRegistryAPI, cnf *config) sacloud.ContainerRegistryAPI {
	return &ContainerRegistryTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *ContainerRegistryTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.ContainerRegistryFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *ContainerRegistryTracer) Create(ctx context.Context, param *sacloud.ContainerRegistryCreateRequest) (*sacloud.ContainerRegistry, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultContainerRegistry, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultContainerRegistry", resultContainerRegistry))

	}
	return resultContainerRegistry, err
}

// Read is API call with trace log
func (t *ContainerRegistryTracer) Read(ctx context.Context, id types.ID) (*sacloud.ContainerRegistry, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultContainerRegistry, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultContainerRegistry", resultContainerRegistry))

	}
	return resultContainerRegistry, err
}

// Update is API call with trace log
func (t *ContainerRegistryTracer) Update(ctx context.Context, id types.ID, param *sacloud.ContainerRegistryUpdateRequest) (*sacloud.ContainerRegistry, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultContainerRegistry, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultContainerRegistry", resultContainerRegistry))

	}
	return resultContainerRegistry, err
}

// UpdateSettings is API call with trace log
func (t *ContainerRegistryTracer) UpdateSettings(ctx context.Context, id types.ID, param *sacloud.ContainerRegistryUpdateSettingsRequest) (*sacloud.ContainerRegistry, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultContainerRegistry, err := t.Internal.UpdateSettings(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultContainerRegistry", resultContainerRegistry))

	}
	return resultContainerRegistry, err
}

// Delete is API call with trace log
func (t *ContainerRegistryTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ListUsers is API call with trace log
func (t *ContainerRegistryTracer) ListUsers(ctx context.Context, id types.ID) (*sacloud.ContainerRegistryUsers, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.ListUsers", options...)
	defer func() {
		span.End()
	}()

	resultContainerRegistryUsers, err := t.Internal.ListUsers(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultContainerRegistryUsers", resultContainerRegistryUsers))

	}
	return resultContainerRegistryUsers, err
}

// AddUser is API call with trace log
func (t *ContainerRegistryTracer) AddUser(ctx context.Context, id types.ID, param *sacloud.ContainerRegistryUserCreateRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.AddUser", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.AddUser(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// UpdateUser is API call with trace log
func (t *ContainerRegistryTracer) UpdateUser(ctx context.Context, id types.ID, username string, param *sacloud.ContainerRegistryUserUpdateRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.username", username),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.UpdateUser", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.UpdateUser(ctx, id, username, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DeleteUser is API call with trace log
func (t *ContainerRegistryTracer) DeleteUser(ctx context.Context, id types.ID, username string) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.username", username),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ContainerRegistryAPI.DeleteUser", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DeleteUser(ctx, id, username)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* CouponTracer
*************************************************/

// CouponTracer is for trace CouponOp operations
type CouponTracer struct {
	Internal sacloud.CouponAPI
	config   *config
}

// NewCouponTracer creates new CouponTracer instance
func newCouponTracer(in sacloud.CouponAPI, cnf *config) sacloud.CouponAPI {
	return &CouponTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *CouponTracer) Find(ctx context.Context, accountID types.ID) (*sacloud.CouponFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.accountID", accountID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "CouponAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, accountID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

/*************************************************
* DatabaseTracer
*************************************************/

// DatabaseTracer is for trace DatabaseOp operations
type DatabaseTracer struct {
	Internal sacloud.DatabaseAPI
	config   *config
}

// NewDatabaseTracer creates new DatabaseTracer instance
func newDatabaseTracer(in sacloud.DatabaseAPI, cnf *config) sacloud.DatabaseAPI {
	return &DatabaseTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *DatabaseTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.DatabaseFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *DatabaseTracer) Create(ctx context.Context, zone string, param *sacloud.DatabaseCreateRequest) (*sacloud.Database, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultDatabase, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDatabase", resultDatabase))

	}
	return resultDatabase, err
}

// Read is API call with trace log
func (t *DatabaseTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Database, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultDatabase, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDatabase", resultDatabase))

	}
	return resultDatabase, err
}

// Update is API call with trace log
func (t *DatabaseTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.DatabaseUpdateRequest) (*sacloud.Database, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultDatabase, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDatabase", resultDatabase))

	}
	return resultDatabase, err
}

// UpdateSettings is API call with trace log
func (t *DatabaseTracer) UpdateSettings(ctx context.Context, zone string, id types.ID, param *sacloud.DatabaseUpdateSettingsRequest) (*sacloud.Database, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultDatabase, err := t.Internal.UpdateSettings(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDatabase", resultDatabase))

	}
	return resultDatabase, err
}

// Delete is API call with trace log
func (t *DatabaseTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Config is API call with trace log
func (t *DatabaseTracer) Config(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Config", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Config(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Boot is API call with trace log
func (t *DatabaseTracer) Boot(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Boot", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Boot(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Shutdown is API call with trace log
func (t *DatabaseTracer) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *sacloud.ShutdownOption) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.shutdownOption", shutdownOption),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Shutdown", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Shutdown(ctx, zone, id, shutdownOption)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Reset is API call with trace log
func (t *DatabaseTracer) Reset(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Reset", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Reset(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// MonitorCPU is API call with trace log
func (t *DatabaseTracer) MonitorCPU(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.CPUTimeActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.MonitorCPU", options...)
	defer func() {
		span.End()
	}()

	resultCPUTimeActivity, err := t.Internal.MonitorCPU(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCPUTimeActivity", resultCPUTimeActivity))

	}
	return resultCPUTimeActivity, err
}

// MonitorDisk is API call with trace log
func (t *DatabaseTracer) MonitorDisk(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.DiskActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.MonitorDisk", options...)
	defer func() {
		span.End()
	}()

	resultDiskActivity, err := t.Internal.MonitorDisk(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDiskActivity", resultDiskActivity))

	}
	return resultDiskActivity, err
}

// MonitorInterface is API call with trace log
func (t *DatabaseTracer) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.InterfaceActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.MonitorInterface", options...)
	defer func() {
		span.End()
	}()

	resultInterfaceActivity, err := t.Internal.MonitorInterface(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterfaceActivity", resultInterfaceActivity))

	}
	return resultInterfaceActivity, err
}

// MonitorDatabase is API call with trace log
func (t *DatabaseTracer) MonitorDatabase(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.DatabaseActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.MonitorDatabase", options...)
	defer func() {
		span.End()
	}()

	resultDatabaseActivity, err := t.Internal.MonitorDatabase(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDatabaseActivity", resultDatabaseActivity))

	}
	return resultDatabaseActivity, err
}

// Status is API call with trace log
func (t *DatabaseTracer) Status(ctx context.Context, zone string, id types.ID) (*sacloud.DatabaseStatus, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DatabaseAPI.Status", options...)
	defer func() {
		span.End()
	}()

	resultDatabaseStatus, err := t.Internal.Status(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDatabaseStatus", resultDatabaseStatus))

	}
	return resultDatabaseStatus, err
}

/*************************************************
* DiskTracer
*************************************************/

// DiskTracer is for trace DiskOp operations
type DiskTracer struct {
	Internal sacloud.DiskAPI
	config   *config
}

// NewDiskTracer creates new DiskTracer instance
func newDiskTracer(in sacloud.DiskAPI, cnf *config) sacloud.DiskAPI {
	return &DiskTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *DiskTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.DiskFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *DiskTracer) Create(ctx context.Context, zone string, createParam *sacloud.DiskCreateRequest, distantFrom []types.ID) (*sacloud.Disk, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.createParam", createParam),
		label.Any("libsacloud.api.arguments.distantFrom", distantFrom),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultDisk, err := t.Internal.Create(ctx, zone, createParam, distantFrom)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDisk", resultDisk))

	}
	return resultDisk, err
}

// Config is API call with trace log
func (t *DiskTracer) Config(ctx context.Context, zone string, id types.ID, edit *sacloud.DiskEditRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.edit", edit),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.Config", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Config(ctx, zone, id, edit)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// CreateWithConfig is API call with trace log
func (t *DiskTracer) CreateWithConfig(ctx context.Context, zone string, createParam *sacloud.DiskCreateRequest, editParam *sacloud.DiskEditRequest, bootAtAvailable bool, distantFrom []types.ID) (*sacloud.Disk, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.createParam", createParam),
		label.Any("libsacloud.api.arguments.editParam", editParam),
		label.Any("libsacloud.api.arguments.bootAtAvailable", bootAtAvailable),
		label.Any("libsacloud.api.arguments.distantFrom", distantFrom),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.CreateWithConfig", options...)
	defer func() {
		span.End()
	}()

	resultDisk, err := t.Internal.CreateWithConfig(ctx, zone, createParam, editParam, bootAtAvailable, distantFrom)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDisk", resultDisk))

	}
	return resultDisk, err
}

// ToBlank is API call with trace log
func (t *DiskTracer) ToBlank(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.ToBlank", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ToBlank(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ResizePartition is API call with trace log
func (t *DiskTracer) ResizePartition(ctx context.Context, zone string, id types.ID, param *sacloud.DiskResizePartitionRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.ResizePartition", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ResizePartition(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ConnectToServer is API call with trace log
func (t *DiskTracer) ConnectToServer(ctx context.Context, zone string, id types.ID, serverID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.serverID", serverID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.ConnectToServer", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ConnectToServer(ctx, zone, id, serverID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DisconnectFromServer is API call with trace log
func (t *DiskTracer) DisconnectFromServer(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.DisconnectFromServer", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DisconnectFromServer(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Install is API call with trace log
func (t *DiskTracer) Install(ctx context.Context, zone string, id types.ID, installParam *sacloud.DiskInstallRequest, distantFrom []types.ID) (*sacloud.Disk, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.installParam", installParam),
		label.Any("libsacloud.api.arguments.distantFrom", distantFrom),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.Install", options...)
	defer func() {
		span.End()
	}()

	resultDisk, err := t.Internal.Install(ctx, zone, id, installParam, distantFrom)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDisk", resultDisk))

	}
	return resultDisk, err
}

// Read is API call with trace log
func (t *DiskTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Disk, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultDisk, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDisk", resultDisk))

	}
	return resultDisk, err
}

// Update is API call with trace log
func (t *DiskTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.DiskUpdateRequest) (*sacloud.Disk, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultDisk, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDisk", resultDisk))

	}
	return resultDisk, err
}

// Delete is API call with trace log
func (t *DiskTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Monitor is API call with trace log
func (t *DiskTracer) Monitor(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.DiskActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.Monitor", options...)
	defer func() {
		span.End()
	}()

	resultDiskActivity, err := t.Internal.Monitor(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDiskActivity", resultDiskActivity))

	}
	return resultDiskActivity, err
}

// MonitorDisk is API call with trace log
func (t *DiskTracer) MonitorDisk(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.DiskActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskAPI.MonitorDisk", options...)
	defer func() {
		span.End()
	}()

	resultDiskActivity, err := t.Internal.MonitorDisk(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDiskActivity", resultDiskActivity))

	}
	return resultDiskActivity, err
}

/*************************************************
* DiskPlanTracer
*************************************************/

// DiskPlanTracer is for trace DiskPlanOp operations
type DiskPlanTracer struct {
	Internal sacloud.DiskPlanAPI
	config   *config
}

// NewDiskPlanTracer creates new DiskPlanTracer instance
func newDiskPlanTracer(in sacloud.DiskPlanAPI, cnf *config) sacloud.DiskPlanAPI {
	return &DiskPlanTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *DiskPlanTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.DiskPlanFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskPlanAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *DiskPlanTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.DiskPlan, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DiskPlanAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultDiskPlan, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDiskPlan", resultDiskPlan))

	}
	return resultDiskPlan, err
}

/*************************************************
* DNSTracer
*************************************************/

// DNSTracer is for trace DNSOp operations
type DNSTracer struct {
	Internal sacloud.DNSAPI
	config   *config
}

// NewDNSTracer creates new DNSTracer instance
func newDNSTracer(in sacloud.DNSAPI, cnf *config) sacloud.DNSAPI {
	return &DNSTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *DNSTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.DNSFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DNSAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *DNSTracer) Create(ctx context.Context, param *sacloud.DNSCreateRequest) (*sacloud.DNS, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DNSAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultDNS, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDNS", resultDNS))

	}
	return resultDNS, err
}

// Read is API call with trace log
func (t *DNSTracer) Read(ctx context.Context, id types.ID) (*sacloud.DNS, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DNSAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultDNS, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDNS", resultDNS))

	}
	return resultDNS, err
}

// Update is API call with trace log
func (t *DNSTracer) Update(ctx context.Context, id types.ID, param *sacloud.DNSUpdateRequest) (*sacloud.DNS, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DNSAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultDNS, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDNS", resultDNS))

	}
	return resultDNS, err
}

// UpdateSettings is API call with trace log
func (t *DNSTracer) UpdateSettings(ctx context.Context, id types.ID, param *sacloud.DNSUpdateSettingsRequest) (*sacloud.DNS, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DNSAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultDNS, err := t.Internal.UpdateSettings(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultDNS", resultDNS))

	}
	return resultDNS, err
}

// Delete is API call with trace log
func (t *DNSTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "DNSAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* ESMETracer
*************************************************/

// ESMETracer is for trace ESMEOp operations
type ESMETracer struct {
	Internal sacloud.ESMEAPI
	config   *config
}

// NewESMETracer creates new ESMETracer instance
func newESMETracer(in sacloud.ESMEAPI, cnf *config) sacloud.ESMEAPI {
	return &ESMETracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *ESMETracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.ESMEFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ESMEAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *ESMETracer) Create(ctx context.Context, param *sacloud.ESMECreateRequest) (*sacloud.ESME, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ESMEAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultESME, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultESME", resultESME))

	}
	return resultESME, err
}

// Read is API call with trace log
func (t *ESMETracer) Read(ctx context.Context, id types.ID) (*sacloud.ESME, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ESMEAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultESME, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultESME", resultESME))

	}
	return resultESME, err
}

// Update is API call with trace log
func (t *ESMETracer) Update(ctx context.Context, id types.ID, param *sacloud.ESMEUpdateRequest) (*sacloud.ESME, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ESMEAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultESME, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultESME", resultESME))

	}
	return resultESME, err
}

// Delete is API call with trace log
func (t *ESMETracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ESMEAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// SendMessageWithGeneratedOTP is API call with trace log
func (t *ESMETracer) SendMessageWithGeneratedOTP(ctx context.Context, id types.ID, param *sacloud.ESMESendMessageWithGeneratedOTPRequest) (*sacloud.ESMESendMessageResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ESMEAPI.SendMessageWithGeneratedOTP", options...)
	defer func() {
		span.End()
	}()

	resultESMESendMessageResult, err := t.Internal.SendMessageWithGeneratedOTP(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultESMESendMessageResult", resultESMESendMessageResult))

	}
	return resultESMESendMessageResult, err
}

// SendMessageWithInputtedOTP is API call with trace log
func (t *ESMETracer) SendMessageWithInputtedOTP(ctx context.Context, id types.ID, param *sacloud.ESMESendMessageWithInputtedOTPRequest) (*sacloud.ESMESendMessageResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ESMEAPI.SendMessageWithInputtedOTP", options...)
	defer func() {
		span.End()
	}()

	resultESMESendMessageResult, err := t.Internal.SendMessageWithInputtedOTP(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultESMESendMessageResult", resultESMESendMessageResult))

	}
	return resultESMESendMessageResult, err
}

// Logs is API call with trace log
func (t *ESMETracer) Logs(ctx context.Context, id types.ID) ([]*sacloud.ESMELogs, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ESMEAPI.Logs", options...)
	defer func() {
		span.End()
	}()

	resultLogs, err := t.Internal.Logs(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLogs", resultLogs))

	}
	return resultLogs, err
}

/*************************************************
* GSLBTracer
*************************************************/

// GSLBTracer is for trace GSLBOp operations
type GSLBTracer struct {
	Internal sacloud.GSLBAPI
	config   *config
}

// NewGSLBTracer creates new GSLBTracer instance
func newGSLBTracer(in sacloud.GSLBAPI, cnf *config) sacloud.GSLBAPI {
	return &GSLBTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *GSLBTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.GSLBFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "GSLBAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *GSLBTracer) Create(ctx context.Context, param *sacloud.GSLBCreateRequest) (*sacloud.GSLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "GSLBAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultGSLB, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultGSLB", resultGSLB))

	}
	return resultGSLB, err
}

// Read is API call with trace log
func (t *GSLBTracer) Read(ctx context.Context, id types.ID) (*sacloud.GSLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "GSLBAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultGSLB, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultGSLB", resultGSLB))

	}
	return resultGSLB, err
}

// Update is API call with trace log
func (t *GSLBTracer) Update(ctx context.Context, id types.ID, param *sacloud.GSLBUpdateRequest) (*sacloud.GSLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "GSLBAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultGSLB, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultGSLB", resultGSLB))

	}
	return resultGSLB, err
}

// UpdateSettings is API call with trace log
func (t *GSLBTracer) UpdateSettings(ctx context.Context, id types.ID, param *sacloud.GSLBUpdateSettingsRequest) (*sacloud.GSLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "GSLBAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultGSLB, err := t.Internal.UpdateSettings(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultGSLB", resultGSLB))

	}
	return resultGSLB, err
}

// Delete is API call with trace log
func (t *GSLBTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "GSLBAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* IconTracer
*************************************************/

// IconTracer is for trace IconOp operations
type IconTracer struct {
	Internal sacloud.IconAPI
	config   *config
}

// NewIconTracer creates new IconTracer instance
func newIconTracer(in sacloud.IconAPI, cnf *config) sacloud.IconAPI {
	return &IconTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *IconTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.IconFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IconAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *IconTracer) Create(ctx context.Context, param *sacloud.IconCreateRequest) (*sacloud.Icon, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IconAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultIcon, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIcon", resultIcon))

	}
	return resultIcon, err
}

// Read is API call with trace log
func (t *IconTracer) Read(ctx context.Context, id types.ID) (*sacloud.Icon, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IconAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultIcon, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIcon", resultIcon))

	}
	return resultIcon, err
}

// Update is API call with trace log
func (t *IconTracer) Update(ctx context.Context, id types.ID, param *sacloud.IconUpdateRequest) (*sacloud.Icon, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IconAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultIcon, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIcon", resultIcon))

	}
	return resultIcon, err
}

// Delete is API call with trace log
func (t *IconTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IconAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* InterfaceTracer
*************************************************/

// InterfaceTracer is for trace InterfaceOp operations
type InterfaceTracer struct {
	Internal sacloud.InterfaceAPI
	config   *config
}

// NewInterfaceTracer creates new InterfaceTracer instance
func newInterfaceTracer(in sacloud.InterfaceAPI, cnf *config) sacloud.InterfaceAPI {
	return &InterfaceTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *InterfaceTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.InterfaceFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *InterfaceTracer) Create(ctx context.Context, zone string, param *sacloud.InterfaceCreateRequest) (*sacloud.Interface, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultInterface, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterface", resultInterface))

	}
	return resultInterface, err
}

// Read is API call with trace log
func (t *InterfaceTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Interface, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultInterface, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterface", resultInterface))

	}
	return resultInterface, err
}

// Update is API call with trace log
func (t *InterfaceTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.InterfaceUpdateRequest) (*sacloud.Interface, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultInterface, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterface", resultInterface))

	}
	return resultInterface, err
}

// Delete is API call with trace log
func (t *InterfaceTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Monitor is API call with trace log
func (t *InterfaceTracer) Monitor(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.InterfaceActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.Monitor", options...)
	defer func() {
		span.End()
	}()

	resultInterfaceActivity, err := t.Internal.Monitor(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterfaceActivity", resultInterfaceActivity))

	}
	return resultInterfaceActivity, err
}

// ConnectToSharedSegment is API call with trace log
func (t *InterfaceTracer) ConnectToSharedSegment(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.ConnectToSharedSegment", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ConnectToSharedSegment(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ConnectToSwitch is API call with trace log
func (t *InterfaceTracer) ConnectToSwitch(ctx context.Context, zone string, id types.ID, switchID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.switchID", switchID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.ConnectToSwitch", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ConnectToSwitch(ctx, zone, id, switchID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DisconnectFromSwitch is API call with trace log
func (t *InterfaceTracer) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.DisconnectFromSwitch", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DisconnectFromSwitch(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ConnectToPacketFilter is API call with trace log
func (t *InterfaceTracer) ConnectToPacketFilter(ctx context.Context, zone string, id types.ID, packetFilterID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.packetFilterID", packetFilterID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.ConnectToPacketFilter", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ConnectToPacketFilter(ctx, zone, id, packetFilterID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DisconnectFromPacketFilter is API call with trace log
func (t *InterfaceTracer) DisconnectFromPacketFilter(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InterfaceAPI.DisconnectFromPacketFilter", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DisconnectFromPacketFilter(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* InternetTracer
*************************************************/

// InternetTracer is for trace InternetOp operations
type InternetTracer struct {
	Internal sacloud.InternetAPI
	config   *config
}

// NewInternetTracer creates new InternetTracer instance
func newInternetTracer(in sacloud.InternetAPI, cnf *config) sacloud.InternetAPI {
	return &InternetTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *InternetTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.InternetFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *InternetTracer) Create(ctx context.Context, zone string, param *sacloud.InternetCreateRequest) (*sacloud.Internet, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultInternet, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInternet", resultInternet))

	}
	return resultInternet, err
}

// Read is API call with trace log
func (t *InternetTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Internet, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultInternet, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInternet", resultInternet))

	}
	return resultInternet, err
}

// Update is API call with trace log
func (t *InternetTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.InternetUpdateRequest) (*sacloud.Internet, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultInternet, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInternet", resultInternet))

	}
	return resultInternet, err
}

// Delete is API call with trace log
func (t *InternetTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// UpdateBandWidth is API call with trace log
func (t *InternetTracer) UpdateBandWidth(ctx context.Context, zone string, id types.ID, param *sacloud.InternetUpdateBandWidthRequest) (*sacloud.Internet, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.UpdateBandWidth", options...)
	defer func() {
		span.End()
	}()

	resultInternet, err := t.Internal.UpdateBandWidth(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInternet", resultInternet))

	}
	return resultInternet, err
}

// AddSubnet is API call with trace log
func (t *InternetTracer) AddSubnet(ctx context.Context, zone string, id types.ID, param *sacloud.InternetAddSubnetRequest) (*sacloud.InternetSubnetOperationResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.AddSubnet", options...)
	defer func() {
		span.End()
	}()

	resultSubnet, err := t.Internal.AddSubnet(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSubnet", resultSubnet))

	}
	return resultSubnet, err
}

// UpdateSubnet is API call with trace log
func (t *InternetTracer) UpdateSubnet(ctx context.Context, zone string, id types.ID, subnetID types.ID, param *sacloud.InternetUpdateSubnetRequest) (*sacloud.InternetSubnetOperationResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.subnetID", subnetID),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.UpdateSubnet", options...)
	defer func() {
		span.End()
	}()

	resultSubnet, err := t.Internal.UpdateSubnet(ctx, zone, id, subnetID, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSubnet", resultSubnet))

	}
	return resultSubnet, err
}

// DeleteSubnet is API call with trace log
func (t *InternetTracer) DeleteSubnet(ctx context.Context, zone string, id types.ID, subnetID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.subnetID", subnetID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.DeleteSubnet", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DeleteSubnet(ctx, zone, id, subnetID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Monitor is API call with trace log
func (t *InternetTracer) Monitor(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.RouterActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.Monitor", options...)
	defer func() {
		span.End()
	}()

	resultRouterActivity, err := t.Internal.Monitor(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultRouterActivity", resultRouterActivity))

	}
	return resultRouterActivity, err
}

// MonitorRouter is API call with trace log
func (t *InternetTracer) MonitorRouter(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.RouterActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.MonitorRouter", options...)
	defer func() {
		span.End()
	}()

	resultRouterActivity, err := t.Internal.MonitorRouter(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultRouterActivity", resultRouterActivity))

	}
	return resultRouterActivity, err
}

// EnableIPv6 is API call with trace log
func (t *InternetTracer) EnableIPv6(ctx context.Context, zone string, id types.ID) (*sacloud.IPv6NetInfo, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.EnableIPv6", options...)
	defer func() {
		span.End()
	}()

	resultIPv6Net, err := t.Internal.EnableIPv6(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIPv6Net", resultIPv6Net))

	}
	return resultIPv6Net, err
}

// DisableIPv6 is API call with trace log
func (t *InternetTracer) DisableIPv6(ctx context.Context, zone string, id types.ID, ipv6netID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.ipv6netID", ipv6netID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetAPI.DisableIPv6", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DisableIPv6(ctx, zone, id, ipv6netID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* InternetPlanTracer
*************************************************/

// InternetPlanTracer is for trace InternetPlanOp operations
type InternetPlanTracer struct {
	Internal sacloud.InternetPlanAPI
	config   *config
}

// NewInternetPlanTracer creates new InternetPlanTracer instance
func newInternetPlanTracer(in sacloud.InternetPlanAPI, cnf *config) sacloud.InternetPlanAPI {
	return &InternetPlanTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *InternetPlanTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.InternetPlanFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetPlanAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *InternetPlanTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.InternetPlan, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "InternetPlanAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultInternetPlan, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInternetPlan", resultInternetPlan))

	}
	return resultInternetPlan, err
}

/*************************************************
* IPAddressTracer
*************************************************/

// IPAddressTracer is for trace IPAddressOp operations
type IPAddressTracer struct {
	Internal sacloud.IPAddressAPI
	config   *config
}

// NewIPAddressTracer creates new IPAddressTracer instance
func newIPAddressTracer(in sacloud.IPAddressAPI, cnf *config) sacloud.IPAddressAPI {
	return &IPAddressTracer{
		Internal: in,
		config:   cnf,
	}
}

// List is API call with trace log
func (t *IPAddressTracer) List(ctx context.Context, zone string) (*sacloud.IPAddressListResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPAddressAPI.List", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.List(ctx, zone)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *IPAddressTracer) Read(ctx context.Context, zone string, ipAddress string) (*sacloud.IPAddress, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.ipAddress", ipAddress),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPAddressAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultIPAddress, err := t.Internal.Read(ctx, zone, ipAddress)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIPAddress", resultIPAddress))

	}
	return resultIPAddress, err
}

// UpdateHostName is API call with trace log
func (t *IPAddressTracer) UpdateHostName(ctx context.Context, zone string, ipAddress string, hostName string) (*sacloud.IPAddress, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.ipAddress", ipAddress),
		label.Any("libsacloud.api.arguments.hostName", hostName),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPAddressAPI.UpdateHostName", options...)
	defer func() {
		span.End()
	}()

	resultIPAddress, err := t.Internal.UpdateHostName(ctx, zone, ipAddress, hostName)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIPAddress", resultIPAddress))

	}
	return resultIPAddress, err
}

/*************************************************
* IPv6NetTracer
*************************************************/

// IPv6NetTracer is for trace IPv6NetOp operations
type IPv6NetTracer struct {
	Internal sacloud.IPv6NetAPI
	config   *config
}

// NewIPv6NetTracer creates new IPv6NetTracer instance
func newIPv6NetTracer(in sacloud.IPv6NetAPI, cnf *config) sacloud.IPv6NetAPI {
	return &IPv6NetTracer{
		Internal: in,
		config:   cnf,
	}
}

// List is API call with trace log
func (t *IPv6NetTracer) List(ctx context.Context, zone string) (*sacloud.IPv6NetListResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPv6NetAPI.List", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.List(ctx, zone)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Find is API call with trace log
func (t *IPv6NetTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.IPv6NetFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPv6NetAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *IPv6NetTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.IPv6Net, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPv6NetAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultIPv6Net, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIPv6Net", resultIPv6Net))

	}
	return resultIPv6Net, err
}

/*************************************************
* IPv6AddrTracer
*************************************************/

// IPv6AddrTracer is for trace IPv6AddrOp operations
type IPv6AddrTracer struct {
	Internal sacloud.IPv6AddrAPI
	config   *config
}

// NewIPv6AddrTracer creates new IPv6AddrTracer instance
func newIPv6AddrTracer(in sacloud.IPv6AddrAPI, cnf *config) sacloud.IPv6AddrAPI {
	return &IPv6AddrTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *IPv6AddrTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.IPv6AddrFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPv6AddrAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *IPv6AddrTracer) Create(ctx context.Context, zone string, param *sacloud.IPv6AddrCreateRequest) (*sacloud.IPv6Addr, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPv6AddrAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultIPv6Addr, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIPv6Addr", resultIPv6Addr))

	}
	return resultIPv6Addr, err
}

// Read is API call with trace log
func (t *IPv6AddrTracer) Read(ctx context.Context, zone string, ipv6addr string) (*sacloud.IPv6Addr, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.ipv6addr", ipv6addr),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPv6AddrAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultIPv6Addr, err := t.Internal.Read(ctx, zone, ipv6addr)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIPv6Addr", resultIPv6Addr))

	}
	return resultIPv6Addr, err
}

// Update is API call with trace log
func (t *IPv6AddrTracer) Update(ctx context.Context, zone string, ipv6addr string, param *sacloud.IPv6AddrUpdateRequest) (*sacloud.IPv6Addr, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.ipv6addr", ipv6addr),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPv6AddrAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultIPv6Addr, err := t.Internal.Update(ctx, zone, ipv6addr, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultIPv6Addr", resultIPv6Addr))

	}
	return resultIPv6Addr, err
}

// Delete is API call with trace log
func (t *IPv6AddrTracer) Delete(ctx context.Context, zone string, ipv6addr string) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.ipv6addr", ipv6addr),
	))
	ctx, span = t.config.Tracer.Start(ctx, "IPv6AddrAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, ipv6addr)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* LicenseTracer
*************************************************/

// LicenseTracer is for trace LicenseOp operations
type LicenseTracer struct {
	Internal sacloud.LicenseAPI
	config   *config
}

// NewLicenseTracer creates new LicenseTracer instance
func newLicenseTracer(in sacloud.LicenseAPI, cnf *config) sacloud.LicenseAPI {
	return &LicenseTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *LicenseTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.LicenseFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LicenseAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *LicenseTracer) Create(ctx context.Context, param *sacloud.LicenseCreateRequest) (*sacloud.License, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LicenseAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultLicense, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLicense", resultLicense))

	}
	return resultLicense, err
}

// Read is API call with trace log
func (t *LicenseTracer) Read(ctx context.Context, id types.ID) (*sacloud.License, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LicenseAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultLicense, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLicense", resultLicense))

	}
	return resultLicense, err
}

// Update is API call with trace log
func (t *LicenseTracer) Update(ctx context.Context, id types.ID, param *sacloud.LicenseUpdateRequest) (*sacloud.License, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LicenseAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultLicense, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLicense", resultLicense))

	}
	return resultLicense, err
}

// Delete is API call with trace log
func (t *LicenseTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LicenseAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* LicenseInfoTracer
*************************************************/

// LicenseInfoTracer is for trace LicenseInfoOp operations
type LicenseInfoTracer struct {
	Internal sacloud.LicenseInfoAPI
	config   *config
}

// NewLicenseInfoTracer creates new LicenseInfoTracer instance
func newLicenseInfoTracer(in sacloud.LicenseInfoAPI, cnf *config) sacloud.LicenseInfoAPI {
	return &LicenseInfoTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *LicenseInfoTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.LicenseInfoFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LicenseInfoAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *LicenseInfoTracer) Read(ctx context.Context, id types.ID) (*sacloud.LicenseInfo, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LicenseInfoAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultLicenseInfo, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLicenseInfo", resultLicenseInfo))

	}
	return resultLicenseInfo, err
}

/*************************************************
* LoadBalancerTracer
*************************************************/

// LoadBalancerTracer is for trace LoadBalancerOp operations
type LoadBalancerTracer struct {
	Internal sacloud.LoadBalancerAPI
	config   *config
}

// NewLoadBalancerTracer creates new LoadBalancerTracer instance
func newLoadBalancerTracer(in sacloud.LoadBalancerAPI, cnf *config) sacloud.LoadBalancerAPI {
	return &LoadBalancerTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *LoadBalancerTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.LoadBalancerFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *LoadBalancerTracer) Create(ctx context.Context, zone string, param *sacloud.LoadBalancerCreateRequest) (*sacloud.LoadBalancer, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultLoadBalancer, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLoadBalancer", resultLoadBalancer))

	}
	return resultLoadBalancer, err
}

// Read is API call with trace log
func (t *LoadBalancerTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.LoadBalancer, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultLoadBalancer, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLoadBalancer", resultLoadBalancer))

	}
	return resultLoadBalancer, err
}

// Update is API call with trace log
func (t *LoadBalancerTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.LoadBalancerUpdateRequest) (*sacloud.LoadBalancer, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultLoadBalancer, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLoadBalancer", resultLoadBalancer))

	}
	return resultLoadBalancer, err
}

// UpdateSettings is API call with trace log
func (t *LoadBalancerTracer) UpdateSettings(ctx context.Context, zone string, id types.ID, param *sacloud.LoadBalancerUpdateSettingsRequest) (*sacloud.LoadBalancer, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultLoadBalancer, err := t.Internal.UpdateSettings(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLoadBalancer", resultLoadBalancer))

	}
	return resultLoadBalancer, err
}

// Delete is API call with trace log
func (t *LoadBalancerTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Config is API call with trace log
func (t *LoadBalancerTracer) Config(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Config", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Config(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Boot is API call with trace log
func (t *LoadBalancerTracer) Boot(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Boot", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Boot(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Shutdown is API call with trace log
func (t *LoadBalancerTracer) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *sacloud.ShutdownOption) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.shutdownOption", shutdownOption),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Shutdown", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Shutdown(ctx, zone, id, shutdownOption)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Reset is API call with trace log
func (t *LoadBalancerTracer) Reset(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Reset", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Reset(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// MonitorInterface is API call with trace log
func (t *LoadBalancerTracer) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.InterfaceActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.MonitorInterface", options...)
	defer func() {
		span.End()
	}()

	resultInterfaceActivity, err := t.Internal.MonitorInterface(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterfaceActivity", resultInterfaceActivity))

	}
	return resultInterfaceActivity, err
}

// Status is API call with trace log
func (t *LoadBalancerTracer) Status(ctx context.Context, zone string, id types.ID) (*sacloud.LoadBalancerStatusResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LoadBalancerAPI.Status", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Status(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

/*************************************************
* LocalRouterTracer
*************************************************/

// LocalRouterTracer is for trace LocalRouterOp operations
type LocalRouterTracer struct {
	Internal sacloud.LocalRouterAPI
	config   *config
}

// NewLocalRouterTracer creates new LocalRouterTracer instance
func newLocalRouterTracer(in sacloud.LocalRouterAPI, cnf *config) sacloud.LocalRouterAPI {
	return &LocalRouterTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *LocalRouterTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.LocalRouterFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LocalRouterAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *LocalRouterTracer) Create(ctx context.Context, param *sacloud.LocalRouterCreateRequest) (*sacloud.LocalRouter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LocalRouterAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultLocalRouter, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLocalRouter", resultLocalRouter))

	}
	return resultLocalRouter, err
}

// Read is API call with trace log
func (t *LocalRouterTracer) Read(ctx context.Context, id types.ID) (*sacloud.LocalRouter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LocalRouterAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultLocalRouter, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLocalRouter", resultLocalRouter))

	}
	return resultLocalRouter, err
}

// Update is API call with trace log
func (t *LocalRouterTracer) Update(ctx context.Context, id types.ID, param *sacloud.LocalRouterUpdateRequest) (*sacloud.LocalRouter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LocalRouterAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultLocalRouter, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLocalRouter", resultLocalRouter))

	}
	return resultLocalRouter, err
}

// UpdateSettings is API call with trace log
func (t *LocalRouterTracer) UpdateSettings(ctx context.Context, id types.ID, param *sacloud.LocalRouterUpdateSettingsRequest) (*sacloud.LocalRouter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LocalRouterAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultLocalRouter, err := t.Internal.UpdateSettings(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLocalRouter", resultLocalRouter))

	}
	return resultLocalRouter, err
}

// Delete is API call with trace log
func (t *LocalRouterTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LocalRouterAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// HealthStatus is API call with trace log
func (t *LocalRouterTracer) HealthStatus(ctx context.Context, id types.ID) (*sacloud.LocalRouterHealth, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LocalRouterAPI.HealthStatus", options...)
	defer func() {
		span.End()
	}()

	resultLocalRouterHealth, err := t.Internal.HealthStatus(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLocalRouterHealth", resultLocalRouterHealth))

	}
	return resultLocalRouterHealth, err
}

// MonitorLocalRouter is API call with trace log
func (t *LocalRouterTracer) MonitorLocalRouter(ctx context.Context, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.LocalRouterActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "LocalRouterAPI.MonitorLocalRouter", options...)
	defer func() {
		span.End()
	}()

	resultLocalRouterActivity, err := t.Internal.MonitorLocalRouter(ctx, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLocalRouterActivity", resultLocalRouterActivity))

	}
	return resultLocalRouterActivity, err
}

/*************************************************
* MobileGatewayTracer
*************************************************/

// MobileGatewayTracer is for trace MobileGatewayOp operations
type MobileGatewayTracer struct {
	Internal sacloud.MobileGatewayAPI
	config   *config
}

// NewMobileGatewayTracer creates new MobileGatewayTracer instance
func newMobileGatewayTracer(in sacloud.MobileGatewayAPI, cnf *config) sacloud.MobileGatewayAPI {
	return &MobileGatewayTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *MobileGatewayTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.MobileGatewayFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *MobileGatewayTracer) Create(ctx context.Context, zone string, param *sacloud.MobileGatewayCreateRequest) (*sacloud.MobileGateway, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultMobileGateway, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultMobileGateway", resultMobileGateway))

	}
	return resultMobileGateway, err
}

// Read is API call with trace log
func (t *MobileGatewayTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.MobileGateway, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultMobileGateway, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultMobileGateway", resultMobileGateway))

	}
	return resultMobileGateway, err
}

// Update is API call with trace log
func (t *MobileGatewayTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.MobileGatewayUpdateRequest) (*sacloud.MobileGateway, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultMobileGateway, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultMobileGateway", resultMobileGateway))

	}
	return resultMobileGateway, err
}

// UpdateSettings is API call with trace log
func (t *MobileGatewayTracer) UpdateSettings(ctx context.Context, zone string, id types.ID, param *sacloud.MobileGatewayUpdateSettingsRequest) (*sacloud.MobileGateway, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultMobileGateway, err := t.Internal.UpdateSettings(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultMobileGateway", resultMobileGateway))

	}
	return resultMobileGateway, err
}

// Delete is API call with trace log
func (t *MobileGatewayTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Config is API call with trace log
func (t *MobileGatewayTracer) Config(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Config", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Config(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Boot is API call with trace log
func (t *MobileGatewayTracer) Boot(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Boot", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Boot(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Shutdown is API call with trace log
func (t *MobileGatewayTracer) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *sacloud.ShutdownOption) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.shutdownOption", shutdownOption),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Shutdown", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Shutdown(ctx, zone, id, shutdownOption)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Reset is API call with trace log
func (t *MobileGatewayTracer) Reset(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Reset", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Reset(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ConnectToSwitch is API call with trace log
func (t *MobileGatewayTracer) ConnectToSwitch(ctx context.Context, zone string, id types.ID, switchID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.switchID", switchID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.ConnectToSwitch", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ConnectToSwitch(ctx, zone, id, switchID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DisconnectFromSwitch is API call with trace log
func (t *MobileGatewayTracer) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.DisconnectFromSwitch", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DisconnectFromSwitch(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// GetDNS is API call with trace log
func (t *MobileGatewayTracer) GetDNS(ctx context.Context, zone string, id types.ID) (*sacloud.MobileGatewayDNSSetting, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.GetDNS", options...)
	defer func() {
		span.End()
	}()

	resultSIMGroup, err := t.Internal.GetDNS(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSIMGroup", resultSIMGroup))

	}
	return resultSIMGroup, err
}

// SetDNS is API call with trace log
func (t *MobileGatewayTracer) SetDNS(ctx context.Context, zone string, id types.ID, param *sacloud.MobileGatewayDNSSetting) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.SetDNS", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.SetDNS(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// GetSIMRoutes is API call with trace log
func (t *MobileGatewayTracer) GetSIMRoutes(ctx context.Context, zone string, id types.ID) (sacloud.MobileGatewaySIMRoutes, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.GetSIMRoutes", options...)
	defer func() {
		span.End()
	}()

	resultSIMRoutes, err := t.Internal.GetSIMRoutes(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSIMRoutes", resultSIMRoutes))

	}
	return resultSIMRoutes, err
}

// SetSIMRoutes is API call with trace log
func (t *MobileGatewayTracer) SetSIMRoutes(ctx context.Context, zone string, id types.ID, param []*sacloud.MobileGatewaySIMRouteParam) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.SetSIMRoutes", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.SetSIMRoutes(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ListSIM is API call with trace log
func (t *MobileGatewayTracer) ListSIM(ctx context.Context, zone string, id types.ID) (sacloud.MobileGatewaySIMs, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.ListSIM", options...)
	defer func() {
		span.End()
	}()

	resultSIM, err := t.Internal.ListSIM(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSIM", resultSIM))

	}
	return resultSIM, err
}

// AddSIM is API call with trace log
func (t *MobileGatewayTracer) AddSIM(ctx context.Context, zone string, id types.ID, param *sacloud.MobileGatewayAddSIMRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.AddSIM", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.AddSIM(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DeleteSIM is API call with trace log
func (t *MobileGatewayTracer) DeleteSIM(ctx context.Context, zone string, id types.ID, simID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.simID", simID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.DeleteSIM", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DeleteSIM(ctx, zone, id, simID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Logs is API call with trace log
func (t *MobileGatewayTracer) Logs(ctx context.Context, zone string, id types.ID) ([]*sacloud.MobileGatewaySIMLogs, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.Logs", options...)
	defer func() {
		span.End()
	}()

	resultLogs, err := t.Internal.Logs(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLogs", resultLogs))

	}
	return resultLogs, err
}

// GetTrafficConfig is API call with trace log
func (t *MobileGatewayTracer) GetTrafficConfig(ctx context.Context, zone string, id types.ID) (*sacloud.MobileGatewayTrafficControl, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.GetTrafficConfig", options...)
	defer func() {
		span.End()
	}()

	resultTrafficMonitoring, err := t.Internal.GetTrafficConfig(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultTrafficMonitoring", resultTrafficMonitoring))

	}
	return resultTrafficMonitoring, err
}

// SetTrafficConfig is API call with trace log
func (t *MobileGatewayTracer) SetTrafficConfig(ctx context.Context, zone string, id types.ID, param *sacloud.MobileGatewayTrafficControl) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.SetTrafficConfig", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.SetTrafficConfig(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DeleteTrafficConfig is API call with trace log
func (t *MobileGatewayTracer) DeleteTrafficConfig(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.DeleteTrafficConfig", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DeleteTrafficConfig(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// TrafficStatus is API call with trace log
func (t *MobileGatewayTracer) TrafficStatus(ctx context.Context, zone string, id types.ID) (*sacloud.MobileGatewayTrafficStatus, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.TrafficStatus", options...)
	defer func() {
		span.End()
	}()

	resultTrafficStatus, err := t.Internal.TrafficStatus(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultTrafficStatus", resultTrafficStatus))

	}
	return resultTrafficStatus, err
}

// MonitorInterface is API call with trace log
func (t *MobileGatewayTracer) MonitorInterface(ctx context.Context, zone string, id types.ID, index int, condition *sacloud.MonitorCondition) (*sacloud.InterfaceActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.index", index),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "MobileGatewayAPI.MonitorInterface", options...)
	defer func() {
		span.End()
	}()

	resultInterfaceActivity, err := t.Internal.MonitorInterface(ctx, zone, id, index, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterfaceActivity", resultInterfaceActivity))

	}
	return resultInterfaceActivity, err
}

/*************************************************
* NFSTracer
*************************************************/

// NFSTracer is for trace NFSOp operations
type NFSTracer struct {
	Internal sacloud.NFSAPI
	config   *config
}

// NewNFSTracer creates new NFSTracer instance
func newNFSTracer(in sacloud.NFSAPI, cnf *config) sacloud.NFSAPI {
	return &NFSTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *NFSTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.NFSFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *NFSTracer) Create(ctx context.Context, zone string, param *sacloud.NFSCreateRequest) (*sacloud.NFS, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultNFS, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultNFS", resultNFS))

	}
	return resultNFS, err
}

// Read is API call with trace log
func (t *NFSTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.NFS, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultNFS, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultNFS", resultNFS))

	}
	return resultNFS, err
}

// Update is API call with trace log
func (t *NFSTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.NFSUpdateRequest) (*sacloud.NFS, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultNFS, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultNFS", resultNFS))

	}
	return resultNFS, err
}

// Delete is API call with trace log
func (t *NFSTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Boot is API call with trace log
func (t *NFSTracer) Boot(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.Boot", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Boot(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Shutdown is API call with trace log
func (t *NFSTracer) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *sacloud.ShutdownOption) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.shutdownOption", shutdownOption),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.Shutdown", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Shutdown(ctx, zone, id, shutdownOption)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Reset is API call with trace log
func (t *NFSTracer) Reset(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.Reset", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Reset(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// MonitorFreeDiskSize is API call with trace log
func (t *NFSTracer) MonitorFreeDiskSize(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.FreeDiskSizeActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.MonitorFreeDiskSize", options...)
	defer func() {
		span.End()
	}()

	resultFreeDiskSizeActivity, err := t.Internal.MonitorFreeDiskSize(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultFreeDiskSizeActivity", resultFreeDiskSizeActivity))

	}
	return resultFreeDiskSizeActivity, err
}

// MonitorInterface is API call with trace log
func (t *NFSTracer) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.InterfaceActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NFSAPI.MonitorInterface", options...)
	defer func() {
		span.End()
	}()

	resultInterfaceActivity, err := t.Internal.MonitorInterface(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterfaceActivity", resultInterfaceActivity))

	}
	return resultInterfaceActivity, err
}

/*************************************************
* NoteTracer
*************************************************/

// NoteTracer is for trace NoteOp operations
type NoteTracer struct {
	Internal sacloud.NoteAPI
	config   *config
}

// NewNoteTracer creates new NoteTracer instance
func newNoteTracer(in sacloud.NoteAPI, cnf *config) sacloud.NoteAPI {
	return &NoteTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *NoteTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.NoteFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NoteAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *NoteTracer) Create(ctx context.Context, param *sacloud.NoteCreateRequest) (*sacloud.Note, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NoteAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultNote, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultNote", resultNote))

	}
	return resultNote, err
}

// Read is API call with trace log
func (t *NoteTracer) Read(ctx context.Context, id types.ID) (*sacloud.Note, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NoteAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultNote, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultNote", resultNote))

	}
	return resultNote, err
}

// Update is API call with trace log
func (t *NoteTracer) Update(ctx context.Context, id types.ID, param *sacloud.NoteUpdateRequest) (*sacloud.Note, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NoteAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultNote, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultNote", resultNote))

	}
	return resultNote, err
}

// Delete is API call with trace log
func (t *NoteTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "NoteAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* PacketFilterTracer
*************************************************/

// PacketFilterTracer is for trace PacketFilterOp operations
type PacketFilterTracer struct {
	Internal sacloud.PacketFilterAPI
	config   *config
}

// NewPacketFilterTracer creates new PacketFilterTracer instance
func newPacketFilterTracer(in sacloud.PacketFilterAPI, cnf *config) sacloud.PacketFilterAPI {
	return &PacketFilterTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *PacketFilterTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.PacketFilterFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PacketFilterAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *PacketFilterTracer) Create(ctx context.Context, zone string, param *sacloud.PacketFilterCreateRequest) (*sacloud.PacketFilter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PacketFilterAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultPacketFilter, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultPacketFilter", resultPacketFilter))

	}
	return resultPacketFilter, err
}

// Read is API call with trace log
func (t *PacketFilterTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.PacketFilter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PacketFilterAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultPacketFilter, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultPacketFilter", resultPacketFilter))

	}
	return resultPacketFilter, err
}

// Update is API call with trace log
func (t *PacketFilterTracer) Update(ctx context.Context, zone string, id types.ID, updateParam *sacloud.PacketFilterUpdateRequest, originalExpressionHash string) (*sacloud.PacketFilter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.updateParam", updateParam),
		label.Any("libsacloud.api.arguments.originalExpressionHash", originalExpressionHash),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PacketFilterAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultPacketFilter, err := t.Internal.Update(ctx, zone, id, updateParam, originalExpressionHash)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultPacketFilter", resultPacketFilter))

	}
	return resultPacketFilter, err
}

// Delete is API call with trace log
func (t *PacketFilterTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PacketFilterAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* PrivateHostTracer
*************************************************/

// PrivateHostTracer is for trace PrivateHostOp operations
type PrivateHostTracer struct {
	Internal sacloud.PrivateHostAPI
	config   *config
}

// NewPrivateHostTracer creates new PrivateHostTracer instance
func newPrivateHostTracer(in sacloud.PrivateHostAPI, cnf *config) sacloud.PrivateHostAPI {
	return &PrivateHostTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *PrivateHostTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.PrivateHostFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PrivateHostAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *PrivateHostTracer) Create(ctx context.Context, zone string, param *sacloud.PrivateHostCreateRequest) (*sacloud.PrivateHost, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PrivateHostAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultPrivateHost, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultPrivateHost", resultPrivateHost))

	}
	return resultPrivateHost, err
}

// Read is API call with trace log
func (t *PrivateHostTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.PrivateHost, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PrivateHostAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultPrivateHost, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultPrivateHost", resultPrivateHost))

	}
	return resultPrivateHost, err
}

// Update is API call with trace log
func (t *PrivateHostTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.PrivateHostUpdateRequest) (*sacloud.PrivateHost, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PrivateHostAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultPrivateHost, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultPrivateHost", resultPrivateHost))

	}
	return resultPrivateHost, err
}

// Delete is API call with trace log
func (t *PrivateHostTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PrivateHostAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* PrivateHostPlanTracer
*************************************************/

// PrivateHostPlanTracer is for trace PrivateHostPlanOp operations
type PrivateHostPlanTracer struct {
	Internal sacloud.PrivateHostPlanAPI
	config   *config
}

// NewPrivateHostPlanTracer creates new PrivateHostPlanTracer instance
func newPrivateHostPlanTracer(in sacloud.PrivateHostPlanAPI, cnf *config) sacloud.PrivateHostPlanAPI {
	return &PrivateHostPlanTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *PrivateHostPlanTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.PrivateHostPlanFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PrivateHostPlanAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *PrivateHostPlanTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.PrivateHostPlan, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "PrivateHostPlanAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultPrivateHostPlan, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultPrivateHostPlan", resultPrivateHostPlan))

	}
	return resultPrivateHostPlan, err
}

/*************************************************
* ProxyLBTracer
*************************************************/

// ProxyLBTracer is for trace ProxyLBOp operations
type ProxyLBTracer struct {
	Internal sacloud.ProxyLBAPI
	config   *config
}

// NewProxyLBTracer creates new ProxyLBTracer instance
func newProxyLBTracer(in sacloud.ProxyLBAPI, cnf *config) sacloud.ProxyLBAPI {
	return &ProxyLBTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *ProxyLBTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.ProxyLBFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *ProxyLBTracer) Create(ctx context.Context, param *sacloud.ProxyLBCreateRequest) (*sacloud.ProxyLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultProxyLB, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultProxyLB", resultProxyLB))

	}
	return resultProxyLB, err
}

// Read is API call with trace log
func (t *ProxyLBTracer) Read(ctx context.Context, id types.ID) (*sacloud.ProxyLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultProxyLB, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultProxyLB", resultProxyLB))

	}
	return resultProxyLB, err
}

// Update is API call with trace log
func (t *ProxyLBTracer) Update(ctx context.Context, id types.ID, param *sacloud.ProxyLBUpdateRequest) (*sacloud.ProxyLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultProxyLB, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultProxyLB", resultProxyLB))

	}
	return resultProxyLB, err
}

// UpdateSettings is API call with trace log
func (t *ProxyLBTracer) UpdateSettings(ctx context.Context, id types.ID, param *sacloud.ProxyLBUpdateSettingsRequest) (*sacloud.ProxyLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultProxyLB, err := t.Internal.UpdateSettings(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultProxyLB", resultProxyLB))

	}
	return resultProxyLB, err
}

// Delete is API call with trace log
func (t *ProxyLBTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ChangePlan is API call with trace log
func (t *ProxyLBTracer) ChangePlan(ctx context.Context, id types.ID, param *sacloud.ProxyLBChangePlanRequest) (*sacloud.ProxyLB, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.ChangePlan", options...)
	defer func() {
		span.End()
	}()

	resultProxyLB, err := t.Internal.ChangePlan(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultProxyLB", resultProxyLB))

	}
	return resultProxyLB, err
}

// GetCertificates is API call with trace log
func (t *ProxyLBTracer) GetCertificates(ctx context.Context, id types.ID) (*sacloud.ProxyLBCertificates, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.GetCertificates", options...)
	defer func() {
		span.End()
	}()

	resultProxyLBCertificates, err := t.Internal.GetCertificates(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultProxyLBCertificates", resultProxyLBCertificates))

	}
	return resultProxyLBCertificates, err
}

// SetCertificates is API call with trace log
func (t *ProxyLBTracer) SetCertificates(ctx context.Context, id types.ID, param *sacloud.ProxyLBSetCertificatesRequest) (*sacloud.ProxyLBCertificates, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.SetCertificates", options...)
	defer func() {
		span.End()
	}()

	resultProxyLBCertificates, err := t.Internal.SetCertificates(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultProxyLBCertificates", resultProxyLBCertificates))

	}
	return resultProxyLBCertificates, err
}

// DeleteCertificates is API call with trace log
func (t *ProxyLBTracer) DeleteCertificates(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.DeleteCertificates", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DeleteCertificates(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// RenewLetsEncryptCert is API call with trace log
func (t *ProxyLBTracer) RenewLetsEncryptCert(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.RenewLetsEncryptCert", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.RenewLetsEncryptCert(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// HealthStatus is API call with trace log
func (t *ProxyLBTracer) HealthStatus(ctx context.Context, id types.ID) (*sacloud.ProxyLBHealth, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.HealthStatus", options...)
	defer func() {
		span.End()
	}()

	resultProxyLBHealth, err := t.Internal.HealthStatus(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultProxyLBHealth", resultProxyLBHealth))

	}
	return resultProxyLBHealth, err
}

// MonitorConnection is API call with trace log
func (t *ProxyLBTracer) MonitorConnection(ctx context.Context, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.ConnectionActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ProxyLBAPI.MonitorConnection", options...)
	defer func() {
		span.End()
	}()

	resultConnectionActivity, err := t.Internal.MonitorConnection(ctx, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultConnectionActivity", resultConnectionActivity))

	}
	return resultConnectionActivity, err
}

/*************************************************
* RegionTracer
*************************************************/

// RegionTracer is for trace RegionOp operations
type RegionTracer struct {
	Internal sacloud.RegionAPI
	config   *config
}

// NewRegionTracer creates new RegionTracer instance
func newRegionTracer(in sacloud.RegionAPI, cnf *config) sacloud.RegionAPI {
	return &RegionTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *RegionTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.RegionFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "RegionAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *RegionTracer) Read(ctx context.Context, id types.ID) (*sacloud.Region, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "RegionAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultRegion, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultRegion", resultRegion))

	}
	return resultRegion, err
}

/*************************************************
* ServerTracer
*************************************************/

// ServerTracer is for trace ServerOp operations
type ServerTracer struct {
	Internal sacloud.ServerAPI
	config   *config
}

// NewServerTracer creates new ServerTracer instance
func newServerTracer(in sacloud.ServerAPI, cnf *config) sacloud.ServerAPI {
	return &ServerTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *ServerTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.ServerFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *ServerTracer) Create(ctx context.Context, zone string, param *sacloud.ServerCreateRequest) (*sacloud.Server, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultServer, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultServer", resultServer))

	}
	return resultServer, err
}

// Read is API call with trace log
func (t *ServerTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Server, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultServer, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultServer", resultServer))

	}
	return resultServer, err
}

// Update is API call with trace log
func (t *ServerTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.ServerUpdateRequest) (*sacloud.Server, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultServer, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultServer", resultServer))

	}
	return resultServer, err
}

// Delete is API call with trace log
func (t *ServerTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DeleteWithDisks is API call with trace log
func (t *ServerTracer) DeleteWithDisks(ctx context.Context, zone string, id types.ID, disks *sacloud.ServerDeleteWithDisksRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.disks", disks),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.DeleteWithDisks", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DeleteWithDisks(ctx, zone, id, disks)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ChangePlan is API call with trace log
func (t *ServerTracer) ChangePlan(ctx context.Context, zone string, id types.ID, plan *sacloud.ServerChangePlanRequest) (*sacloud.Server, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.plan", plan),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.ChangePlan", options...)
	defer func() {
		span.End()
	}()

	resultServer, err := t.Internal.ChangePlan(ctx, zone, id, plan)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultServer", resultServer))

	}
	return resultServer, err
}

// InsertCDROM is API call with trace log
func (t *ServerTracer) InsertCDROM(ctx context.Context, zone string, id types.ID, insertParam *sacloud.InsertCDROMRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.insertParam", insertParam),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.InsertCDROM", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.InsertCDROM(ctx, zone, id, insertParam)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// EjectCDROM is API call with trace log
func (t *ServerTracer) EjectCDROM(ctx context.Context, zone string, id types.ID, ejectParam *sacloud.EjectCDROMRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.ejectParam", ejectParam),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.EjectCDROM", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.EjectCDROM(ctx, zone, id, ejectParam)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Boot is API call with trace log
func (t *ServerTracer) Boot(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Boot", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Boot(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Shutdown is API call with trace log
func (t *ServerTracer) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *sacloud.ShutdownOption) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.shutdownOption", shutdownOption),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Shutdown", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Shutdown(ctx, zone, id, shutdownOption)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Reset is API call with trace log
func (t *ServerTracer) Reset(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Reset", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Reset(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// SendKey is API call with trace log
func (t *ServerTracer) SendKey(ctx context.Context, zone string, id types.ID, keyboardParam *sacloud.SendKeyRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.keyboardParam", keyboardParam),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.SendKey", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.SendKey(ctx, zone, id, keyboardParam)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// GetVNCProxy is API call with trace log
func (t *ServerTracer) GetVNCProxy(ctx context.Context, zone string, id types.ID) (*sacloud.VNCProxyInfo, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.GetVNCProxy", options...)
	defer func() {
		span.End()
	}()

	resultVNCProxyInfo, err := t.Internal.GetVNCProxy(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultVNCProxyInfo", resultVNCProxyInfo))

	}
	return resultVNCProxyInfo, err
}

// Monitor is API call with trace log
func (t *ServerTracer) Monitor(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.CPUTimeActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.Monitor", options...)
	defer func() {
		span.End()
	}()

	resultCPUTimeActivity, err := t.Internal.Monitor(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCPUTimeActivity", resultCPUTimeActivity))

	}
	return resultCPUTimeActivity, err
}

// MonitorCPU is API call with trace log
func (t *ServerTracer) MonitorCPU(ctx context.Context, zone string, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.CPUTimeActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerAPI.MonitorCPU", options...)
	defer func() {
		span.End()
	}()

	resultCPUTimeActivity, err := t.Internal.MonitorCPU(ctx, zone, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCPUTimeActivity", resultCPUTimeActivity))

	}
	return resultCPUTimeActivity, err
}

/*************************************************
* ServerPlanTracer
*************************************************/

// ServerPlanTracer is for trace ServerPlanOp operations
type ServerPlanTracer struct {
	Internal sacloud.ServerPlanAPI
	config   *config
}

// NewServerPlanTracer creates new ServerPlanTracer instance
func newServerPlanTracer(in sacloud.ServerPlanAPI, cnf *config) sacloud.ServerPlanAPI {
	return &ServerPlanTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *ServerPlanTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.ServerPlanFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerPlanAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *ServerPlanTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.ServerPlan, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServerPlanAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultServerPlan, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultServerPlan", resultServerPlan))

	}
	return resultServerPlan, err
}

/*************************************************
* ServiceClassTracer
*************************************************/

// ServiceClassTracer is for trace ServiceClassOp operations
type ServiceClassTracer struct {
	Internal sacloud.ServiceClassAPI
	config   *config
}

// NewServiceClassTracer creates new ServiceClassTracer instance
func newServiceClassTracer(in sacloud.ServiceClassAPI, cnf *config) sacloud.ServiceClassAPI {
	return &ServiceClassTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *ServiceClassTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.ServiceClassFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ServiceClassAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

/*************************************************
* SIMTracer
*************************************************/

// SIMTracer is for trace SIMOp operations
type SIMTracer struct {
	Internal sacloud.SIMAPI
	config   *config
}

// NewSIMTracer creates new SIMTracer instance
func newSIMTracer(in sacloud.SIMAPI, cnf *config) sacloud.SIMAPI {
	return &SIMTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *SIMTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.SIMFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *SIMTracer) Create(ctx context.Context, param *sacloud.SIMCreateRequest) (*sacloud.SIM, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultSIM, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSIM", resultSIM))

	}
	return resultSIM, err
}

// Read is API call with trace log
func (t *SIMTracer) Read(ctx context.Context, id types.ID) (*sacloud.SIM, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultSIM, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSIM", resultSIM))

	}
	return resultSIM, err
}

// Update is API call with trace log
func (t *SIMTracer) Update(ctx context.Context, id types.ID, param *sacloud.SIMUpdateRequest) (*sacloud.SIM, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultSIM, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSIM", resultSIM))

	}
	return resultSIM, err
}

// Delete is API call with trace log
func (t *SIMTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Activate is API call with trace log
func (t *SIMTracer) Activate(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Activate", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Activate(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Deactivate is API call with trace log
func (t *SIMTracer) Deactivate(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Deactivate", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Deactivate(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// AssignIP is API call with trace log
func (t *SIMTracer) AssignIP(ctx context.Context, id types.ID, param *sacloud.SIMAssignIPRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.AssignIP", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.AssignIP(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ClearIP is API call with trace log
func (t *SIMTracer) ClearIP(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.ClearIP", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ClearIP(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// IMEILock is API call with trace log
func (t *SIMTracer) IMEILock(ctx context.Context, id types.ID, param *sacloud.SIMIMEILockRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.IMEILock", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.IMEILock(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// IMEIUnlock is API call with trace log
func (t *SIMTracer) IMEIUnlock(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.IMEIUnlock", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.IMEIUnlock(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Logs is API call with trace log
func (t *SIMTracer) Logs(ctx context.Context, id types.ID) (*sacloud.SIMLogsResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Logs", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Logs(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// GetNetworkOperator is API call with trace log
func (t *SIMTracer) GetNetworkOperator(ctx context.Context, id types.ID) ([]*sacloud.SIMNetworkOperatorConfig, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.GetNetworkOperator", options...)
	defer func() {
		span.End()
	}()

	resultConfigs, err := t.Internal.GetNetworkOperator(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultConfigs", resultConfigs))

	}
	return resultConfigs, err
}

// SetNetworkOperator is API call with trace log
func (t *SIMTracer) SetNetworkOperator(ctx context.Context, id types.ID, configs []*sacloud.SIMNetworkOperatorConfig) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.configs", configs),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.SetNetworkOperator", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.SetNetworkOperator(ctx, id, configs)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// MonitorSIM is API call with trace log
func (t *SIMTracer) MonitorSIM(ctx context.Context, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.LinkActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.MonitorSIM", options...)
	defer func() {
		span.End()
	}()

	resultLinkActivity, err := t.Internal.MonitorSIM(ctx, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultLinkActivity", resultLinkActivity))

	}
	return resultLinkActivity, err
}

// Status is API call with trace log
func (t *SIMTracer) Status(ctx context.Context, id types.ID) (*sacloud.SIMInfo, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SIMAPI.Status", options...)
	defer func() {
		span.End()
	}()

	resultSIM, err := t.Internal.Status(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSIM", resultSIM))

	}
	return resultSIM, err
}

/*************************************************
* SimpleMonitorTracer
*************************************************/

// SimpleMonitorTracer is for trace SimpleMonitorOp operations
type SimpleMonitorTracer struct {
	Internal sacloud.SimpleMonitorAPI
	config   *config
}

// NewSimpleMonitorTracer creates new SimpleMonitorTracer instance
func newSimpleMonitorTracer(in sacloud.SimpleMonitorAPI, cnf *config) sacloud.SimpleMonitorAPI {
	return &SimpleMonitorTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *SimpleMonitorTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.SimpleMonitorFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SimpleMonitorAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *SimpleMonitorTracer) Create(ctx context.Context, param *sacloud.SimpleMonitorCreateRequest) (*sacloud.SimpleMonitor, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SimpleMonitorAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultSimpleMonitor, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSimpleMonitor", resultSimpleMonitor))

	}
	return resultSimpleMonitor, err
}

// Read is API call with trace log
func (t *SimpleMonitorTracer) Read(ctx context.Context, id types.ID) (*sacloud.SimpleMonitor, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SimpleMonitorAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultSimpleMonitor, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSimpleMonitor", resultSimpleMonitor))

	}
	return resultSimpleMonitor, err
}

// Update is API call with trace log
func (t *SimpleMonitorTracer) Update(ctx context.Context, id types.ID, param *sacloud.SimpleMonitorUpdateRequest) (*sacloud.SimpleMonitor, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SimpleMonitorAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultSimpleMonitor, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSimpleMonitor", resultSimpleMonitor))

	}
	return resultSimpleMonitor, err
}

// UpdateSettings is API call with trace log
func (t *SimpleMonitorTracer) UpdateSettings(ctx context.Context, id types.ID, param *sacloud.SimpleMonitorUpdateSettingsRequest) (*sacloud.SimpleMonitor, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SimpleMonitorAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultSimpleMonitor, err := t.Internal.UpdateSettings(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSimpleMonitor", resultSimpleMonitor))

	}
	return resultSimpleMonitor, err
}

// Delete is API call with trace log
func (t *SimpleMonitorTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SimpleMonitorAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// MonitorResponseTime is API call with trace log
func (t *SimpleMonitorTracer) MonitorResponseTime(ctx context.Context, id types.ID, condition *sacloud.MonitorCondition) (*sacloud.ResponseTimeSecActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SimpleMonitorAPI.MonitorResponseTime", options...)
	defer func() {
		span.End()
	}()

	resultResponseTimeSecActivity, err := t.Internal.MonitorResponseTime(ctx, id, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultResponseTimeSecActivity", resultResponseTimeSecActivity))

	}
	return resultResponseTimeSecActivity, err
}

// HealthStatus is API call with trace log
func (t *SimpleMonitorTracer) HealthStatus(ctx context.Context, id types.ID) (*sacloud.SimpleMonitorHealthStatus, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SimpleMonitorAPI.HealthStatus", options...)
	defer func() {
		span.End()
	}()

	resultSimpleMonitorHealthStatus, err := t.Internal.HealthStatus(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSimpleMonitorHealthStatus", resultSimpleMonitorHealthStatus))

	}
	return resultSimpleMonitorHealthStatus, err
}

/*************************************************
* SSHKeyTracer
*************************************************/

// SSHKeyTracer is for trace SSHKeyOp operations
type SSHKeyTracer struct {
	Internal sacloud.SSHKeyAPI
	config   *config
}

// NewSSHKeyTracer creates new SSHKeyTracer instance
func newSSHKeyTracer(in sacloud.SSHKeyAPI, cnf *config) sacloud.SSHKeyAPI {
	return &SSHKeyTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *SSHKeyTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.SSHKeyFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SSHKeyAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *SSHKeyTracer) Create(ctx context.Context, param *sacloud.SSHKeyCreateRequest) (*sacloud.SSHKey, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SSHKeyAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultSSHKey, err := t.Internal.Create(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSSHKey", resultSSHKey))

	}
	return resultSSHKey, err
}

// Generate is API call with trace log
func (t *SSHKeyTracer) Generate(ctx context.Context, param *sacloud.SSHKeyGenerateRequest) (*sacloud.SSHKeyGenerated, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SSHKeyAPI.Generate", options...)
	defer func() {
		span.End()
	}()

	resultSSHKeyGenerated, err := t.Internal.Generate(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSSHKeyGenerated", resultSSHKeyGenerated))

	}
	return resultSSHKeyGenerated, err
}

// Read is API call with trace log
func (t *SSHKeyTracer) Read(ctx context.Context, id types.ID) (*sacloud.SSHKey, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SSHKeyAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultSSHKey, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSSHKey", resultSSHKey))

	}
	return resultSSHKey, err
}

// Update is API call with trace log
func (t *SSHKeyTracer) Update(ctx context.Context, id types.ID, param *sacloud.SSHKeyUpdateRequest) (*sacloud.SSHKey, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SSHKeyAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultSSHKey, err := t.Internal.Update(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSSHKey", resultSSHKey))

	}
	return resultSSHKey, err
}

// Delete is API call with trace log
func (t *SSHKeyTracer) Delete(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SSHKeyAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

/*************************************************
* SubnetTracer
*************************************************/

// SubnetTracer is for trace SubnetOp operations
type SubnetTracer struct {
	Internal sacloud.SubnetAPI
	config   *config
}

// NewSubnetTracer creates new SubnetTracer instance
func newSubnetTracer(in sacloud.SubnetAPI, cnf *config) sacloud.SubnetAPI {
	return &SubnetTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *SubnetTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.SubnetFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SubnetAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *SubnetTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Subnet, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SubnetAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultSubnet, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSubnet", resultSubnet))

	}
	return resultSubnet, err
}

/*************************************************
* SwitchTracer
*************************************************/

// SwitchTracer is for trace SwitchOp operations
type SwitchTracer struct {
	Internal sacloud.SwitchAPI
	config   *config
}

// NewSwitchTracer creates new SwitchTracer instance
func newSwitchTracer(in sacloud.SwitchAPI, cnf *config) sacloud.SwitchAPI {
	return &SwitchTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *SwitchTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.SwitchFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SwitchAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *SwitchTracer) Create(ctx context.Context, zone string, param *sacloud.SwitchCreateRequest) (*sacloud.Switch, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SwitchAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultSwitch, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSwitch", resultSwitch))

	}
	return resultSwitch, err
}

// Read is API call with trace log
func (t *SwitchTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.Switch, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SwitchAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultSwitch, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSwitch", resultSwitch))

	}
	return resultSwitch, err
}

// Update is API call with trace log
func (t *SwitchTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.SwitchUpdateRequest) (*sacloud.Switch, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SwitchAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultSwitch, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultSwitch", resultSwitch))

	}
	return resultSwitch, err
}

// Delete is API call with trace log
func (t *SwitchTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SwitchAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ConnectToBridge is API call with trace log
func (t *SwitchTracer) ConnectToBridge(ctx context.Context, zone string, id types.ID, bridgeID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.bridgeID", bridgeID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SwitchAPI.ConnectToBridge", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ConnectToBridge(ctx, zone, id, bridgeID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DisconnectFromBridge is API call with trace log
func (t *SwitchTracer) DisconnectFromBridge(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SwitchAPI.DisconnectFromBridge", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DisconnectFromBridge(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// GetServers is API call with trace log
func (t *SwitchTracer) GetServers(ctx context.Context, zone string, id types.ID) (*sacloud.SwitchGetServersResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "SwitchAPI.GetServers", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.GetServers(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

/*************************************************
* VPCRouterTracer
*************************************************/

// VPCRouterTracer is for trace VPCRouterOp operations
type VPCRouterTracer struct {
	Internal sacloud.VPCRouterAPI
	config   *config
}

// NewVPCRouterTracer creates new VPCRouterTracer instance
func newVPCRouterTracer(in sacloud.VPCRouterAPI, cnf *config) sacloud.VPCRouterAPI {
	return &VPCRouterTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *VPCRouterTracer) Find(ctx context.Context, zone string, conditions *sacloud.FindCondition) (*sacloud.VPCRouterFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, zone, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Create is API call with trace log
func (t *VPCRouterTracer) Create(ctx context.Context, zone string, param *sacloud.VPCRouterCreateRequest) (*sacloud.VPCRouter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Create", options...)
	defer func() {
		span.End()
	}()

	resultVPCRouter, err := t.Internal.Create(ctx, zone, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultVPCRouter", resultVPCRouter))

	}
	return resultVPCRouter, err
}

// Read is API call with trace log
func (t *VPCRouterTracer) Read(ctx context.Context, zone string, id types.ID) (*sacloud.VPCRouter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultVPCRouter, err := t.Internal.Read(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultVPCRouter", resultVPCRouter))

	}
	return resultVPCRouter, err
}

// Update is API call with trace log
func (t *VPCRouterTracer) Update(ctx context.Context, zone string, id types.ID, param *sacloud.VPCRouterUpdateRequest) (*sacloud.VPCRouter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Update", options...)
	defer func() {
		span.End()
	}()

	resultVPCRouter, err := t.Internal.Update(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultVPCRouter", resultVPCRouter))

	}
	return resultVPCRouter, err
}

// UpdateSettings is API call with trace log
func (t *VPCRouterTracer) UpdateSettings(ctx context.Context, zone string, id types.ID, param *sacloud.VPCRouterUpdateSettingsRequest) (*sacloud.VPCRouter, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.UpdateSettings", options...)
	defer func() {
		span.End()
	}()

	resultVPCRouter, err := t.Internal.UpdateSettings(ctx, zone, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultVPCRouter", resultVPCRouter))

	}
	return resultVPCRouter, err
}

// Delete is API call with trace log
func (t *VPCRouterTracer) Delete(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Delete", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Delete(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Config is API call with trace log
func (t *VPCRouterTracer) Config(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Config", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Config(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Boot is API call with trace log
func (t *VPCRouterTracer) Boot(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Boot", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Boot(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Shutdown is API call with trace log
func (t *VPCRouterTracer) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *sacloud.ShutdownOption) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.shutdownOption", shutdownOption),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Shutdown", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Shutdown(ctx, zone, id, shutdownOption)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// Reset is API call with trace log
func (t *VPCRouterTracer) Reset(ctx context.Context, zone string, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Reset", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.Reset(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// ConnectToSwitch is API call with trace log
func (t *VPCRouterTracer) ConnectToSwitch(ctx context.Context, zone string, id types.ID, nicIndex int, switchID types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.nicIndex", nicIndex),
		label.Any("libsacloud.api.arguments.switchID", switchID),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.ConnectToSwitch", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.ConnectToSwitch(ctx, zone, id, nicIndex, switchID)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DisconnectFromSwitch is API call with trace log
func (t *VPCRouterTracer) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID, nicIndex int) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.nicIndex", nicIndex),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.DisconnectFromSwitch", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DisconnectFromSwitch(ctx, zone, id, nicIndex)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// MonitorInterface is API call with trace log
func (t *VPCRouterTracer) MonitorInterface(ctx context.Context, zone string, id types.ID, index int, condition *sacloud.MonitorCondition) (*sacloud.InterfaceActivity, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.index", index),
		label.Any("libsacloud.api.arguments.condition", condition),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.MonitorInterface", options...)
	defer func() {
		span.End()
	}()

	resultInterfaceActivity, err := t.Internal.MonitorInterface(ctx, zone, id, index, condition)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultInterfaceActivity", resultInterfaceActivity))

	}
	return resultInterfaceActivity, err
}

// Status is API call with trace log
func (t *VPCRouterTracer) Status(ctx context.Context, zone string, id types.ID) (*sacloud.VPCRouterStatus, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.String("libsacloud.api.arguments.zone", zone),
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "VPCRouterAPI.Status", options...)
	defer func() {
		span.End()
	}()

	resultVPCRouterStatus, err := t.Internal.Status(ctx, zone, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultVPCRouterStatus", resultVPCRouterStatus))

	}
	return resultVPCRouterStatus, err
}

/*************************************************
* WebAccelTracer
*************************************************/

// WebAccelTracer is for trace WebAccelOp operations
type WebAccelTracer struct {
	Internal sacloud.WebAccelAPI
	config   *config
}

// NewWebAccelTracer creates new WebAccelTracer instance
func newWebAccelTracer(in sacloud.WebAccelAPI, cnf *config) sacloud.WebAccelAPI {
	return &WebAccelTracer{
		Internal: in,
		config:   cnf,
	}
}

// List is API call with trace log
func (t *WebAccelTracer) List(ctx context.Context) (*sacloud.WebAccelListResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes())
	ctx, span = t.config.Tracer.Start(ctx, "WebAccelAPI.List", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.List(ctx)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *WebAccelTracer) Read(ctx context.Context, id types.ID) (*sacloud.WebAccel, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "WebAccelAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultWebAccel, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultWebAccel", resultWebAccel))

	}
	return resultWebAccel, err
}

// ReadCertificate is API call with trace log
func (t *WebAccelTracer) ReadCertificate(ctx context.Context, id types.ID) (*sacloud.WebAccelCerts, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "WebAccelAPI.ReadCertificate", options...)
	defer func() {
		span.End()
	}()

	resultCertificate, err := t.Internal.ReadCertificate(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCertificate", resultCertificate))

	}
	return resultCertificate, err
}

// CreateCertificate is API call with trace log
func (t *WebAccelTracer) CreateCertificate(ctx context.Context, id types.ID, param *sacloud.WebAccelCertRequest) (*sacloud.WebAccelCerts, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "WebAccelAPI.CreateCertificate", options...)
	defer func() {
		span.End()
	}()

	resultCertificate, err := t.Internal.CreateCertificate(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCertificate", resultCertificate))

	}
	return resultCertificate, err
}

// UpdateCertificate is API call with trace log
func (t *WebAccelTracer) UpdateCertificate(ctx context.Context, id types.ID, param *sacloud.WebAccelCertRequest) (*sacloud.WebAccelCerts, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "WebAccelAPI.UpdateCertificate", options...)
	defer func() {
		span.End()
	}()

	resultCertificate, err := t.Internal.UpdateCertificate(ctx, id, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultCertificate", resultCertificate))

	}
	return resultCertificate, err
}

// DeleteCertificate is API call with trace log
func (t *WebAccelTracer) DeleteCertificate(ctx context.Context, id types.ID) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "WebAccelAPI.DeleteCertificate", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DeleteCertificate(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DeleteAllCache is API call with trace log
func (t *WebAccelTracer) DeleteAllCache(ctx context.Context, param *sacloud.WebAccelDeleteAllCacheRequest) error {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "WebAccelAPI.DeleteAllCache", options...)
	defer func() {
		span.End()
	}()

	err := t.Internal.DeleteAllCache(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")

	}
	return err
}

// DeleteCache is API call with trace log
func (t *WebAccelTracer) DeleteCache(ctx context.Context, param *sacloud.WebAccelDeleteCacheRequest) ([]*sacloud.WebAccelDeleteCacheResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.param", param),
	))
	ctx, span = t.config.Tracer.Start(ctx, "WebAccelAPI.DeleteCache", options...)
	defer func() {
		span.End()
	}()

	resultResults, err := t.Internal.DeleteCache(ctx, param)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultResults", resultResults))

	}
	return resultResults, err
}

/*************************************************
* ZoneTracer
*************************************************/

// ZoneTracer is for trace ZoneOp operations
type ZoneTracer struct {
	Internal sacloud.ZoneAPI
	config   *config
}

// NewZoneTracer creates new ZoneTracer instance
func newZoneTracer(in sacloud.ZoneAPI, cnf *config) sacloud.ZoneAPI {
	return &ZoneTracer{
		Internal: in,
		config:   cnf,
	}
}

// Find is API call with trace log
func (t *ZoneTracer) Find(ctx context.Context, conditions *sacloud.FindCondition) (*sacloud.ZoneFindResult, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.conditions", conditions),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ZoneAPI.Find", options...)
	defer func() {
		span.End()
	}()

	result, err := t.Internal.Find(ctx, conditions)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.result", result))

	}
	return result, err
}

// Read is API call with trace log
func (t *ZoneTracer) Read(ctx context.Context, id types.ID) (*sacloud.Zone, error) {
	var span trace.Span
	options := append(t.config.SpanStartOptions, trace.WithAttributes(
		label.Any("libsacloud.api.arguments.id", id),
	))
	ctx, span = t.config.Tracer.Start(ctx, "ZoneAPI.Read", options...)
	defer func() {
		span.End()
	}()

	resultZone, err := t.Internal.Read(ctx, id)

	if err != nil {
		span.SetStatus(codes.Error, err.Error())
	} else {
		span.SetStatus(codes.Ok, "")
		span.SetAttributes(label.Any("libsacloud.api.results.resultZone", resultZone))

	}
	return resultZone, err
}
